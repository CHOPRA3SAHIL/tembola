<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Housie Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --primary-light: #818cf8;
            --secondary: #f3f4f6;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --text-primary: #111827;
            --text-secondary: #6b7280;
            --border: #e5e7eb;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            --radius: 0.75rem;
            --radius-lg: 1rem;
        }

        /* Prevent pull to refresh on mobile */
        body {
            overscroll-behavior-y: contain;
        }

        /* Confetti Animation - Simplified for better compatibility */
        @keyframes confetti-fall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }


/* Neon theme for notifications */
.game-notification.neon-theme {
    background: linear-gradient(135deg, #000000 0%, #1a1a2e 100%);
    border: 2px solid transparent;

}

.game-notification.neon-theme::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5, #ffbe0b, #ff006e);
    background-size: 300% 300%;
    border-radius: 50px;
    z-index: -1;
    animation: neon-border-glow 3s ease infinite;
    filter: blur(3px);
}

@keyframes neon-border-glow {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

.game-notification.neon-theme .icon {
    filter: drop-shadow(0 0 10px currentColor);
    animation: neon-pulse 1.5s ease-in-out infinite;
}

@keyframes neon-pulse {
    0%, 100% { transform: scale(1); opacity: 1; }
    50% { transform: scale(1.1); opacity: 0.8; }
}

.game-notification.neon-theme .text {
    color: #ffffff;
    text-shadow: 0 0 10px rgba(255, 255, 255, 0.8),
                 0 0 20px rgba(255, 255, 255, 0.6),
                 0 0 30px rgba(255, 255, 255, 0.4);
    font-weight: 700;
}

.game-notification.neon-theme .amount {
    background: linear-gradient(45deg, #ff006e, #ffbe0b);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    filter: drop-shadow(0 0 15px rgba(255, 190, 11, 0.8));
    font-weight: 900;
}

/* Royal Gold theme */
.game-notification.royal-theme {
    background: linear-gradient(135deg, #1a1a1a 0%, #2d2416 25%, #3d2f1f 50%, #2d2416 75%, #1a1a1a 100%);
    border: 2px solid #d4af37;

    box-shadow: 
        0 0 30px rgba(212, 175, 55, 0.4),
        0 4px 20px rgba(0, 0, 0, 0.5),
        inset 0 0 20px rgba(212, 175, 55, 0.2);
}

.game-notification.royal-theme::before {
    content: '♔';
    position: absolute;
    top: -15px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 20px;
    color: #d4af37;
    filter: drop-shadow(0 0 10px rgba(212, 175, 55, 0.8));
    animation: royal-crown-float 2s ease-in-out infinite;
}

@keyframes royal-crown-float {
    0%, 100% { transform: translateX(-50%) translateY(0) rotate(-5deg); }
    50% { transform: translateX(-50%) translateY(-3px) rotate(5deg); }
}

.game-notification.royal-theme .icon {
    color: #d4af37;
    filter: drop-shadow(0 0 8px rgba(212, 175, 55, 0.6));
}

.game-notification.royal-theme .text {
    color: #ffffff;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
    font-weight: 600;
    letter-spacing: 0.5px;
}

.game-notification.royal-theme .amount {
    background: linear-gradient(135deg, #d4af37 0%, #f4e4bc 50%, #d4af37 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    font-weight: 900;
    filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    animation: royal-shine 2s ease-in-out infinite;
}

@keyframes royal-shine {
    0%, 100% { filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3)) brightness(1); }
    50% { filter: drop-shadow(0 2px 8px rgba(212, 175, 55, 0.6)) brightness(1.2); }
}

/* Aurora Borealis theme */
.game-notification.aurora-theme {
    background: linear-gradient(180deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
    border: 2px solid rgba(255, 255, 255, 0.2);

}

.game-notification.aurora-theme::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, 
        transparent, 
        rgba(0, 255, 170, 0.3), 
        transparent, 
        rgba(0, 170, 255, 0.3), 
        transparent, 
        rgba(170, 0, 255, 0.3), 
        transparent);
    animation: aurora-wave 6s ease-in-out infinite;
    filter: blur(20px);
}

.game-notification.aurora-theme::after {
    content: '';
    position: absolute;
    top: -50%;
    right: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(-45deg, 
        transparent, 
        rgba(255, 0, 170, 0.3), 
        transparent, 
        rgba(255, 170, 0, 0.3), 
        transparent);
    animation: aurora-wave 8s ease-in-out infinite reverse;
    filter: blur(25px);
}

@keyframes aurora-wave {
    0%, 100% { transform: translate(0, 0) rotate(0deg); }
    33% { transform: translate(30px, -30px) rotate(120deg); }
    66% { transform: translate(-20px, 20px) rotate(240deg); }
}

.game-notification.aurora-theme .icon {
    color: #ffffff;
    filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.8));
    z-index: 1;
}

.game-notification.aurora-theme .text {
    color: #ffffff;
    font-weight: 700;
    text-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
    z-index: 1;
    position: relative;
}

.game-notification.aurora-theme .amount {
    background: linear-gradient(90deg, #00ffaa, #00aaff, #aa00ff, #ff00aa);
    background-size: 200% 100%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    font-weight: 900;
    filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.5));
    animation: aurora-text-slide 3s ease-in-out infinite;
    z-index: 1;
    position: relative;
}

@keyframes aurora-text-slide {
    0%, 100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
}

/* Matrix Digital theme */
.game-notification.matrix-theme {
    background: #000000;
    border: 2px solid #00ff00;
    position: relative;
    overflow: hidden;
    font-family: 'Courier New', monospace;
}

.game-notification.matrix-theme::before {
    content: '10101010 11001100 01010101 10011001 11110000 00001111';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    color: #00ff00;
    font-size: 8px;
    opacity: 0.1;
    overflow: hidden;
    white-space: nowrap;
    animation: matrix-scroll 10s linear infinite;
}

.game-notification.matrix-theme::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(180deg, 
        transparent 0%, 
        rgba(0, 255, 0, 0.1) 50%, 
        transparent 100%);
    animation: matrix-scan 2s linear infinite;
}

@keyframes matrix-scroll {
    from { transform: translateX(0); }
    to { transform: translateX(-50%); }
}

@keyframes matrix-scan {
    from { transform: translateY(-100%); }
    to { transform: translateY(100%); }
}

.game-notification.matrix-theme .icon {
    color: #00ff00;
    filter: drop-shadow(0 0 5px #00ff00);
    animation: matrix-flicker 0.1s infinite;
    z-index: 1;
    position: relative;
}

@keyframes matrix-flicker {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.8; }
}

.game-notification.matrix-theme .text {
    color: #00ff00;
    text-transform: uppercase;
    font-weight: 700;
    text-shadow: 0 0 10px #00ff00;
    letter-spacing: 1px;
    z-index: 1;
    position: relative;
}

.game-notification.matrix-theme .amount {
    color: #00ff00;
    font-weight: 900;
    text-shadow: 0 0 15px #00ff00, 0 0 30px #00ff00;
    animation: matrix-pulse 1s ease-in-out infinite;
    z-index: 1;
    position: relative;
}

@keyframes matrix-pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.8; transform: scale(1.05); }
}

/* Fix positioning for ALL themed notifications */
.game-notification.neon-theme,
.game-notification.royal-theme,
.game-notification.aurora-theme,
.game-notification.matrix-theme {
    position: fixed !important;
    overflow: hidden !important;
    transform: translateX(-50%) translateY(0) !important;
    bottom: 20px !important;
}

/* Ensure the pseudo-elements don't break positioning */
.game-notification.neon-theme::before,
.game-notification.royal-theme::before,
.game-notification.aurora-theme::before,
.game-notification.aurora-theme::after {
    pointer-events: none;
}

/* Fix z-index stacking */
.game-notification {
    z-index: 9999 !important;
}

/* Celebration Effects CSS */
.fireworks-container,
.starburst-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;
    z-index: 9999;
}

.firework {
    position: absolute;
    width: 4px;
    height: 4px;
    border-radius: 50%;
    bottom: 0;
}

@keyframes firework-launch {
    0% {
        transform: translateY(0) scale(1);
        opacity: 1;
    }
    100% {
        transform: translateY(-60vh) scale(1);
        opacity: 1;
    }
}

.firework-burst {
    position: absolute;
    width: 4px;
    height: 4px;
    border-radius: 50%;
}

@keyframes firework-burst {
    0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
    }
    100% {
        transform: translate(var(--vx, 0), var(--vy, 0)) scale(0.2);
        opacity: 0;
    }
}

.star-particle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: white;
    clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
}

@keyframes star-shoot {
    0% {
        transform: translate(0, 0) scale(0) rotate(0deg);
        opacity: 0;
    }
    10% {
        transform: translate(0, 0) scale(1.5) rotate(36deg);
        opacity: 1;
    }
    100% {
        transform: translate(var(--vx, 0), var(--vy, 0)) scale(0) rotate(720deg);
        opacity: 0;
    }
}
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 9999;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #f0f;
            top: -10px;
        }
        /* Number calling animation */
        @keyframes number-pulse {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            50% {
                transform: scale(1.2);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .number-calling {
            animation: number-pulse 1s ease-out;
        }

        /* Winning pattern highlight */
        @keyframes pattern-glow {
            0%, 100% {
                box-shadow: 0 0 5px #10b981, 0 0 10px #10b981, 0 0 15px #10b981;
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 10px #10b981, 0 0 20px #10b981, 0 0 30px #10b981;
                transform: scale(1.05);
            }
        }

        .pattern-winner {
            animation: pattern-glow 1.5s ease-in-out infinite;
            border-color: #10b981 !important;
            background: #10b981 !important;
            color: white !important;
            position: relative;
            z-index: 10;
        }
        
        /* Special pattern winner styling for vibrant theme */
        .ticket.theme-vibrant .pattern-winner {
            animation: vibrant-pattern-glow 1.5s ease-in-out infinite !important;
        }
        
        @keyframes vibrant-pattern-glow {
            0%, 100% {
                box-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 
                           0 0 20px currentColor,
                           0 0 30px currentColor,
                           inset 0 0 15px rgba(255, 255, 255, 0.5);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 20px rgba(255, 255, 255, 1), 
                           0 0 40px currentColor,
                           0 0 60px currentColor,
                           inset 0 0 20px rgba(255, 255, 255, 0.7);
                transform: scale(1.1);
            }
        }

        /* Info icon styles */
        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-light);
            color: white;
            font-size: 12px;
            cursor: pointer;
            margin-left: 8px;
            transition: all 0.2s ease;
        }

        .info-icon:hover {
            transform: scale(1.1);
            background: var(--primary);
        }

        /* Game info popup */
        .game-info-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 1.5rem;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            max-width: 400px;
            z-index: 1001;
            border: 1px solid var(--border);
        }

        .game-info-popup h3 {
            margin-bottom: 0.5rem;
            color: var(--primary);
        }

        .game-info-popup p {
            margin: 0.5rem 0;
            font-size: 0.875rem;
            line-height: 1.5;
        }

        .game-info-popup .close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 24px;
            height: 24px;
            border: none;
            background: var(--secondary);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .game-info-popup .close-btn:hover {
            background: var(--primary);
            color: white;
        }

        .popup-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

/* Compact bottom toast notification */
.game-notification {
    position: fixed !important;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%) translateY(100px);
    padding: 12px 20px;
    border-radius: 50px;
    box-shadow: 
        0 4px 20px rgba(0, 0, 0, 0.25),
        0 2px 8px rgba(0, 0, 0, 0.15);
    z-index: 9999;
    display: flex;
    align-items: center;
    gap: 10px;
    font-weight: 600;
    animation: slideUp 0.3s ease-out forwards;
    white-space: nowrap;
    transition: bottom 0.3s ease;
    max-width: 90vw; /* Prevent overflow on mobile */
}

@keyframes slideUp {
    to {
        transform: translateX(-50%) translateY(0);
    }
}

@keyframes slideDown {
    from {
        transform: translateX(-50%) translateY(0);
    }
    to {
        transform: translateX(-50%) translateY(100px);
    }
}

/* Too late notification */
.too-late-notification {
    background: #ef4444;
    color: white;
    border: 2px solid #dc2626;
}

/* Winner celebration */
.winner-celebration {
    background: #10b981;
    color: white;
    border: 2px solid #059669;
}

.game-notification .icon {
    font-size: 20px;
}

.game-notification .text {
    font-size: 14px;
}

.game-notification .amount {
    font-size: 16px;
    font-weight: 800;
    margin-left: 8px;
}
/* Progress bar */
.notification-progress {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 3px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 0 0 16px 16px;
    overflow: hidden;
}

.notification-progress::after {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.5);
    transform-origin: left;
    animation: progressShrink var(--duration) linear;
}

@keyframes progressShrink {
    from { transform: scaleX(1); }
    to { transform: scaleX(0); }
}
/* Progress bar at bottom */
.too-late-notification::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    height: 3px;
    background: rgba(255, 255, 255, 0.5);
    border-radius: 0 0 1rem 1rem;
    animation: progressShrink var(--popup-duration, 5s) linear forwards;
}

@keyframes progressShrink {
    from { width: 100%; }
    to { width: 0%; }
}

/* Hide animation */
@keyframes toastSlideOut {
    to {
        transform: translateX(400px);
        opacity: 0;
    }
}
        /* Rage click warning styles */
        .rage-click-warning {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            padding: 1.5rem 2rem;
            border-radius: var(--radius-lg);
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.3);
            z-index: 10000;
            text-align: center;
            max-width: 350px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .rage-click-warning h3 {
            font-size: 1.25rem;
            margin-bottom: 0.75rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .rage-click-warning p {
            font-size: 0.875rem;
            line-height: 1.5;
            margin-bottom: 1rem;
        }

        .rage-click-warning input {
            padding: 0.5rem;
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            text-align: center;
            width: 120px;
            margin: 0 auto 1rem;
            display: block;
        }

        .rage-click-warning button {
            background: white;
            color: #d97706;
            border: none;
            padding: 0.5rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .rage-click-warning button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .ticket-locked-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: var(--radius);
            z-index: 100;
        }

        .ticket-locked-content {
            background: white;
            padding: 1.5rem;
            border-radius: var(--radius);
            text-align: center;
            max-width: 300px;
        }

        .ticket-locked-content h4 {
            color: var(--danger);
            margin-bottom: 0.75rem;
        }

        .ticket-locked-content p {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .ticket-locked-content input {
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            font-size: 1rem;
            text-align: center;
            width: 120px;
            margin: 0 auto 1rem;
            display: block;
        }

        .ticket-locked-content button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 0.5rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        /* Predetermined winner badge */
        .predetermined-winner {
            display: inline-block;
            background: linear-gradient(135deg, #f59e0b 0%, #f97316 100%);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        /* Sequence setup section */
        .sequence-setup {
            background: linear-gradient(to bottom right, #fef3c7, #fde68a);
            padding: 1.5rem;
            border-radius: var(--radius);
            margin-bottom: 1.5rem;
            border: 1px solid #fbbf24;
        }
/* Winner distribution section */
.distribution-setup {
    background: linear-gradient(to bottom right, #e0e7ff, #c7d2fe);
    padding: 1.5rem;
    border-radius: var(--radius);
    margin-bottom: 1.5rem;
    border: 1px solid #a5b4fc;
}

.distribution-setup h3 {
    font-size: 0.875rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: #4c1d95;
    margin-bottom: 1rem;
}

.distribution-mode-toggle {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.distribution-mode-toggle label {
    display: flex;
    align-items: flex-start;
    cursor: pointer;
    font-size: 0.875rem;
    padding: 0.75rem;
    border-radius: 0.5rem;
    transition: background 0.2s ease;
}

.distribution-mode-toggle label:hover {
    background: rgba(99, 102, 241, 0.1);
}

.distribution-mode-toggle input[type="radio"] {
    margin-right: 0.75rem;
    margin-top: 0.125rem;
    accent-color: #6366f1;
}

.distribution-description {
    font-size: 0.75rem;
    color: #6b7280;
    margin-top: 0.25rem;
    margin-left: 1.75rem;
}

        .sequence-setup h3 {
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #92400e;
            margin-bottom: 1rem;
        }

        .sequence-mode-toggle {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .sequence-mode-toggle label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 0.875rem;
        }

        .sequence-mode-toggle input[type="radio"] {
            margin-right: 0.5rem;
            accent-color: #f59e0b;
        }

        .predetermined-winners-section {
            margin-top: 1rem;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.8);
            border-radius: var(--radius);
        }

        .predetermined-winner-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
            font-size: 0.875rem;
        }

        .predetermined-winner-item:last-child {
            border-bottom: none;
        }

        /* Claim button styles */
        .claim-section {
            margin-top: 1.5rem;
            padding: 1.5rem;
            background: linear-gradient(to bottom right, #f0f1ff, #e8e9ff);
            border-radius: var(--radius);
            border: 1px solid #d4d6ff;
        }

        .claim-section h4 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--primary);
        }

        .claim-button {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            margin: 0.5rem;
            border: none;
            border-radius: var(--radius);
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .claim-button.active {
            background: var(--success);
            color: white;
        }

        .claim-button.active:hover {
            background: #059669;
            transform: translateY(-1px);
        }

        .claim-button.disabled {
            background: var(--secondary);
            color: var(--text-secondary);
            cursor: not-allowed;
            opacity: 0.5;
        }

        .claim-button.won {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            cursor: default;
        }

        .claim-button.late {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            cursor: default;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #fafafa;
            min-height: 100vh;
            color: var(--text-primary);
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .container {
            max-width: 480px;
            margin: 0 auto;
            padding: 1rem;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 2rem 0 1rem;
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .card {
            background: white;
            border-radius: var(--radius-lg);
            padding: 1.5rem;
            margin-bottom: 1rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border);
        }

        .card h2 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: var(--text-primary);
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 0.75rem 1.5rem;
            margin: 0.5rem 0;
            border: none;
            border-radius: var(--radius);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            text-decoration: none;
            white-space: nowrap;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .btn-secondary {
            background: var(--secondary);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: #e5e7eb;
            transform: translateY(-1px);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-success:hover {
            background: #059669;
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
            transform: translateY(-1px);
            box-shadow: var(--shadow);
        }

        .btn-warning {
            background: var(--warning);
            color: white;
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .input-group {
            margin-bottom: 1.25rem;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            font-size: 0.875rem;
            color: var(--text-primary);
        }

        .input-group input, 
        .input-group select {
            width: 100%;
            padding: 0.625rem 0.875rem;
            border: 1px solid var(--border);
            border-radius: var(--radius);
            font-size: 0.875rem;
            transition: all 0.2s ease;
            background: white;
        }

        .input-group input:focus, 
        .input-group select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgb(99 102 241 / 0.1);
        }
        
        .input-group input[readonly] {
            background-color: #f5f5f5;
            cursor: not-allowed;
        }

        .kitty-section {
            background: linear-gradient(to bottom right, #f9fafb, #f3f4f6);
            padding: 1.5rem;
            border-radius: var(--radius);
            margin-bottom: 1.5rem;
            border: 1px solid var(--border);
        }

        .kitty-section h3 {
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .kitty-total {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
            text-align: center;
            margin: 1.5rem 0;
            padding: 1rem;
            background: white;
            border-radius: var(--radius);
            border: 1px solid var(--border);
        }

        .game-type-card {
            background: white;
            padding: 1rem;
            border-radius: var(--radius);
            margin-bottom: 0.75rem;
            border: 1px solid var(--border);
            transition: all 0.2s ease;
        }

        .game-type-card.selected {
            background: #f0f1ff;
            border-color: var(--primary);
        }

        .game-type-card:hover {
            border-color: var(--primary-light);
            box-shadow: var(--shadow-sm);
        }

        .game-type-header {
            display: flex;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .game-type-header input[type="checkbox"] {
            width: 1.25rem;
            height: 1.25rem;
            margin-right: 0.75rem;
            cursor: pointer;
            accent-color: var(--primary);
        }

        .game-type-header label {
            cursor: pointer;
            font-weight: 500;
            font-size: 0.9375rem;
            flex: 1;
        }

        .game-type-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            padding-left: 2rem;
        }

        .game-type-inputs input {
            padding: 0.5rem;
            font-size: 0.875rem;
            text-align: center;
        }

        .game-type-inputs label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        .game-type-card:has(input[type="checkbox"]:not(:checked)) .game-type-inputs {
            opacity: 0.4;
            pointer-events: none;
        }
        
        .game-type-inputs input[readonly] {
            background-color: #f5f5f5;
            cursor: not-allowed;
        }

        .player-input-card {
            background: #f9fafb;
            padding: 1rem;
            border-radius: var(--radius);
            margin-bottom: 0.75rem;
            border: 1px solid var(--border);
            transition: all 0.2s ease;
        }

        .player-input-card:hover {
            background: white;
            border-color: var(--primary-light);
        }

        .player-input-card h4 {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 0.75rem;
        }

        .player-input-card input {
            margin-bottom: 0.5rem;
        }

        .ticket {
            background: white;
            border-radius: var(--radius);
            padding: 1rem;
            margin-bottom: 1rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border);
            position: relative;
        }

        .ticket-header {
            text-align: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .ticket-header h3 {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .ticket-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 0.25rem;
            margin-bottom: 1rem;
        }

        .ticket-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            font-weight: 600;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s ease;
            background: white;
            position: relative;
            overflow: hidden;
        }

        .ticket-cell:not(:empty):hover {
            transform: scale(1.05);
            border-color: var(--primary);
            background: #f0f1ff;
        }

        .ticket-cell.marked {
            background: var(--success) !important;
            color: white !important;
            border-color: var(--success) !important;
        }

        .ticket-cell.marked::after {
            content: '✓';
            position: absolute;
            font-size: 1.5rem;
            opacity: 0.2;
        }

        .number-board {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 0.25rem;
            margin-bottom: 1.5rem;
        }

        .number-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            font-weight: 500;
            font-size: 0.75rem;
            transition: all 0.2s ease;
            background: white;
            cursor: default;
        }

        .number-cell.called {
            background: var(--success);
            color: white;
            border-color: var(--success);
            font-weight: 600;
        }

        .winner-item {
            background: #f9fafb;
            padding: 1rem;
            margin-bottom: 0.5rem;
            border-radius: var(--radius);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid var(--border);
        }

        .winner-badge {
            background: var(--success);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            max-width: 60%;
            text-align: right;
        }

        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .modal-content {
            background: white;
            padding: 2rem;
            border-radius: var(--radius-lg);
            max-width: 480px;
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: var(--shadow-lg);
        }

        .modal-content h2 {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
        }

        .player-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .player-item {
            background: #f9fafb;
            padding: 1rem;
            margin-bottom: 0.5rem;
            border-radius: var(--radius);
            border: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-item .copy-btn {
            padding: 0.25rem 0.75rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: var(--radius);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .player-item .copy-btn:hover {
            background: var(--primary-dark);
            transform: scale(1.05);
        }

        .hidden {
            display: none !important;
        }

        .game-status {
            text-align: center;
            padding: 1.5rem;
            background: linear-gradient(to bottom right, #f0f1ff, #e8e9ff);
            border-radius: var(--radius);
            margin-bottom: 1.5rem;
            border: 1px solid #d4d6ff;
        }
/* Simple ! button */
.show-winners-btn {
    background: var(--primary);
    color: white;
    border: none;
    padding: 0.5rem 1rem;
    border-radius: 9999px;
    font-weight: bold;
    font-size: 1rem;
    cursor: pointer;
    margin-bottom: 1rem;
}

.show-winners-btn:hover {
    background: var(--primary-dark);
}

        .current-number {
            font-size: 3rem;
            font-weight: 700;
            color: var(--primary);
            margin: 1rem 0;
            line-height: 1;
        }
#lastNumbers {
    max-width: 90%;
    margin: 0 auto;
    line-height: 1.4;
    word-wrap: break-word;
}
.current-number {
    font-size: 3rem;
    font-weight: 700;
    color: var(--primary);
    margin: 1rem 0;
    line-height: 1;
}

#lastNumbers {
    max-width: 90%;
    margin: 0 auto;
    line-height: 1.4;
    word-wrap: break-word;
}

/* Settlement table styles */
#settlementResult table {
    border-collapse: collapse;
}

#settlementResult th {
    font-weight: 600;
    color: var(--text-secondary);
    font-size: 0.75rem;
    text-transform: uppercase;
}

#settlementResult td, #settlementResult th {
    padding: 0.5rem;
}

        .claims-container {
            max-height: 250px;
            overflow-y: auto;
            padding: 1rem;
            background: #f9fafb;
            border-radius: var(--radius);
            margin-top: 1.5rem;
        }

        .progress-item {
            margin-bottom: 1rem;
        }

        .progress-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
        }

        .progress-bar {
            width: 100%;
            height: 0.5rem;
            background: var(--border);
            border-radius: 9999px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary);
            border-radius: 9999px;
            transition: width 0.3s ease;
        }

        .progress-fill.low {
            background: var(--danger);
        }

        .progress-fill.medium {
            background: var(--warning);
        }

        .progress-fill.high {
            background: var(--success);
        }

        .voice-mode-group {
            background: #f9fafb;
            padding: 1rem;
            border-radius: var(--radius);
            margin-top: 0.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .voice-mode-group label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 0.875rem;
            color: var(--text-primary);
            padding: 0.5rem;
            border-radius: 0.5rem;
            transition: background 0.2s ease;
        }

        .voice-mode-group label:hover {
            background: #f3f4f6;
        }

        .voice-mode-group input[type="radio"] {
            margin-right: 0.75rem;
            accent-color: var(--primary);
            width: 1rem;
            height: 1rem;
        }

        .winner-summary {
            background: linear-gradient(to bottom right, #f0fdf4, #dcfce7);
            padding: 1.5rem;
            border-radius: var(--radius);
            margin-top: 1.5rem;
            border: 1px solid #bbf7d0;
        }

        .winner-summary h3 {
            color: #059669;
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .winner-summary-item {
            display: flex;
            justify-content: space-between;
            padding: 0.75rem 0;
            border-bottom: 1px solid #d1fae5;
            font-size: 0.9375rem;
        }

        .winner-summary-item:last-child {
            border-bottom: none;
            font-weight: 600;
        }

        .theme-selector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        .theme-btn {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border);
            border-radius: 9999px;
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.8125rem;
            font-weight: 500;
        }

        .theme-btn:hover {
            border-color: var(--primary);
            background: #f0f1ff;
        }

        .theme-btn.active {
            border-color: var(--primary);
            background: var(--primary);
            color: white;
        }

        /* Theme variations */
        .ticket.theme-classic {
            background: #fefefe;
            border: 2px solid #1f2937;
        }

        .ticket.theme-classic .ticket-cell {
            border-color: #374151;
            background: white;
            border-radius: 0.25rem;
        }

        .ticket.theme-classic .ticket-cell.marked {
            background: #dc2626 !important;
            color: white !important;
            border-color: #dc2626 !important;
        }

        .ticket.theme-neon {
            background: #0f172a;
            border: 1px solid #334155;
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.1);
        }

        .ticket.theme-neon .ticket-header {
            color: #e0e7ff;
            border-bottom-color: #334155;
        }

        .ticket.theme-neon .ticket-header h3 {
            color: #e0e7ff;
        }

        .ticket.theme-neon .ticket-cell {
            border-color: #334155;
            background: #1e293b;
            color: #e0e7ff;
            font-weight: 500;
            border-radius: 0.25rem;
        }

        .ticket.theme-neon .ticket-cell.marked {
            background: #8b5cf6 !important;
            color: white !important;
            border-color: #8b5cf6 !important;
            box-shadow: 0 0 12px rgba(139, 92, 246, 0.4);
        }

        .ticket.theme-ocean {
            background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
            border: 1px solid #60a5fa;
        }

        .ticket.theme-ocean .ticket-header {
            color: #1e40af;
            border-bottom-color: #60a5fa;
        }

        .ticket.theme-ocean .ticket-cell {
            border-color: #93c5fd;
            background: rgba(255, 255, 255, 0.9);
            color: #1e40af;
        }

        .ticket.theme-ocean .ticket-cell.marked {
            background: #3b82f6 !important;
            color: white !important;
            border-color: #3b82f6 !important;
        }

        /* Sky Theme */
        .ticket.theme-sky {
            background: linear-gradient(135deg, #1e3a8a 0%, #1e1b4b 50%, #312e81 100%);
            border: 2px solid #fbbf24;
            position: relative;
            overflow: hidden;
        }

        .ticket.theme-sky::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(251, 191, 36, 0.1) 0%, transparent 70%);
            animation: sky-glow 8s ease-in-out infinite;
        }

        @keyframes sky-glow {
            0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.5; }
            50% { transform: translate(-20%, -20%) scale(1.2); opacity: 0.8; }
        }

        .ticket.theme-sky .ticket-header {
            color: #fef3c7;
            border-bottom-color: rgba(251, 191, 36, 0.3);
            text-shadow: 0 2px 8px rgba(251, 191, 36, 0.3);
            position: relative;
            z-index: 1;
        }

        .ticket.theme-sky .ticket-header h3 {
            color: #fef3c7;
            font-weight: 700;
        }

        .ticket.theme-sky .ticket-cell {
            border: 1px solid rgba(251, 191, 36, 0.3);
            background: rgba(30, 58, 138, 0.5);
            color: #fef3c7;
            font-weight: 600;
            border-radius: 0.75rem;
            backdrop-filter: blur(5px);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .ticket.theme-sky .ticket-cell::before {
            content: '';
            position: absolute;
            top: -100%;
            left: -100%;
            width: 300%;
            height: 300%;
            background: linear-gradient(45deg, transparent, rgba(251, 191, 36, 0.2), transparent);
            transform: rotate(45deg);
            transition: all 0.5s ease;
        }

        .ticket.theme-sky .ticket-cell:not(:empty):hover {
            transform: scale(1.1);
            border-color: #fbbf24;
            background: rgba(251, 191, 36, 0.2);
            box-shadow: 0 0 20px rgba(251, 191, 36, 0.4);
        }

        .ticket.theme-sky .ticket-cell:not(:empty):hover::before {
            top: -50%;
            left: -50%;
        }

        .ticket.theme-sky .ticket-cell.marked {
            background: linear-gradient(135deg, #ec4899 0%, #f472b6 100%) !important;
            color: white !important;
            border: 2px solid #fbbf24 !important;
            animation: sky-marked-pulse 2s ease-in-out infinite;
        }

        @keyframes sky-marked-pulse {
            0%, 100% {
                box-shadow: 0 0 15px rgba(236, 72, 153, 0.6),
                           0 0 25px rgba(251, 191, 36, 0.4),
                           inset 0 0 10px rgba(255, 255, 255, 0.3);
            }
            50% {
                box-shadow: 0 0 25px rgba(236, 72, 153, 0.8),
                           0 0 35px rgba(251, 191, 36, 0.6),
                           inset 0 0 15px rgba(255, 255, 255, 0.4);
            }
        }

        .ticket.theme-sky .pattern-winner {
            animation: sky-pattern-winner 1.5s ease-in-out infinite !important;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%) !important;
            color: #1e1b4b !important;
            border: 2px solid #fff !important;
        }

        @keyframes sky-pattern-winner {
            0%, 100% {
                transform: scale(1) rotate(0deg);
                box-shadow: 0 0 20px rgba(251, 191, 36, 0.8),
                           0 0 40px rgba(251, 191, 36, 0.6),
                           0 0 60px rgba(251, 191, 36, 0.4);
            }
            25% {
                transform: scale(1.1) rotate(2deg);
            }
            50% {
                transform: scale(1.15) rotate(-2deg);
                box-shadow: 0 0 30px rgba(251, 191, 36, 1),
                           0 0 50px rgba(251, 191, 36, 0.8),
                           0 0 70px rgba(251, 191, 36, 0.6);
            }
            75% {
                transform: scale(1.1) rotate(2deg);
            }
        }

        .ticket.theme-vibrant {
            background: linear-gradient(135deg, #2a2a3e 0%, #3d2b69 100%);
            border: 2px solid transparent;
            background-clip: padding-box;
            position: relative;
        }

        .ticket.theme-vibrant::before {
            content: '';
            position: absolute;
            top: -2px; right: -2px; bottom: -2px; left: -2px;
            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff, #06ffa5, #ffbe0b, #ff006e);
            background-size: 300% 300%;
            border-radius: var(--radius);
            z-index: -1;
            animation: gradient-border 4s ease infinite;
        }

        @keyframes gradient-border {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .ticket.theme-vibrant .ticket-header {
            color: #ffffff;
            border-bottom-color: rgba(255, 255, 255, 0.2);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .ticket.theme-vibrant .ticket-header h3 {
            color: #ffffff;
        }

        .ticket.theme-vibrant .ticket-cell {
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            font-weight: 600;
            border-radius: 0.5rem;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .ticket.theme-vibrant .ticket-cell:not(:empty):hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .ticket.theme-vibrant .ticket-cell.marked {
            color: white !important;
            border: 1px solid transparent !important;
            animation: vibrant-glow 2s ease-in-out infinite;
        }

        @keyframes vibrant-glow {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 255, 255, 0.6), 
                           0 0 30px currentColor,
                           inset 0 0 10px rgba(255, 255, 255, 0.3);
            }
            50% {
                box-shadow: 0 0 30px rgba(255, 255, 255, 0.8), 
                           0 0 40px currentColor,
                           inset 0 0 15px rgba(255, 255, 255, 0.4);
            }
        }

        /* Vibrant theme color variations for marked cells */
        .ticket.theme-vibrant .ticket-cell.marked.color-1 {
            background: linear-gradient(45deg, #ff006e, #ff4081) !important;
        }
        
        .ticket.theme-vibrant .ticket-cell.marked.color-2 {
            background: linear-gradient(45deg, #8338ec, #9c27b0) !important;
        }
        
        .ticket.theme-vibrant .ticket-cell.marked.color-3 {
            background: linear-gradient(45deg, #3a86ff, #2196f3) !important;
        }
        
        .ticket.theme-vibrant .ticket-cell.marked.color-4 {
            background: linear-gradient(45deg, #06ffa5, #00e676) !important;
        }
        
        .ticket.theme-vibrant .ticket-cell.marked.color-5 {
            background: linear-gradient(45deg, #ffbe0b, #ffc107) !important;
        }
        
        .ticket.theme-vibrant .ticket-cell.marked.color-6 {
            background: linear-gradient(45deg, #ff5722, #f44336) !important;
        }
        
        .ticket.theme-vibrant .ticket-cell.marked.color-7 {
            background: linear-gradient(45deg, #00bcd4, #03a9f4) !important;
        }
        
        .ticket.theme-vibrant .ticket-cell.marked.color-8 {
            background: linear-gradient(45deg, #e91e63, #f50057) !important;
        }
        
        /* Add floating animation for vibrant marked cells */
        .ticket.theme-vibrant .ticket-cell.marked {
            animation: vibrant-float 3s ease-in-out infinite;
        }
        
        @keyframes vibrant-float {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-2px);
            }
        }

        /* Kids Theme */
        .ticket.theme-kids {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 20%, #fecfef 40%, #a8edea 60%, #fed6e3 80%, #ff9a9e 100%);
            border: 3px solid #ff6b6b;
            font-family: 'Comic Sans MS', cursive, sans-serif;
            position: relative;
            overflow: visible;
            box-shadow: 0 10px 30px rgba(255, 107, 107, 0.3);
        }

        /* Emoji decorations */
        .ticket.theme-kids::before,
        .ticket.theme-kids::after {
            position: absolute;
            font-size: 1.5rem;
            animation: kids-float 3s ease-in-out infinite;
            z-index: 1;
        }

        .ticket.theme-kids::before {
            content: '🌟✨🦄🌈🍭';
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            letter-spacing: 1rem;
        }

        .ticket.theme-kids::after {
            content: '🎈🎉🍬🌸🎯';
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            letter-spacing: 1rem;
            animation-delay: 1.5s;
        }

        @keyframes kids-float {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
        }

        .ticket.theme-kids .ticket-header {
            color: #d63031;
            border-bottom: 2px dashed #ff6b6b;
            position: relative;
            z-index: 2;
        }

.ticket.theme-kids .ticket-header h3 {
    color: #c0392b;
    font-size: 1.4rem;
    font-weight: 900;
    text-shadow: 2px 2px 4px rgba(255, 255, 255, 0.8), -1px -1px 2px rgba(0, 0, 0, 0.2);
    animation: kids-bounce 2s ease-in-out infinite;
}

        @keyframes kids-bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

    .ticket.theme-kids .ticket-cell {
    border: 2px solid #ff6b6b;
    background: linear-gradient(135deg, #ffffff 0%, #fff5f5 100%);
    color: #d63031;
    font-weight: 900;
    font-size: 1.1rem;
    border-radius: 50%;
    animation: kids-rainbow-text 5s ease-in-out infinite;
    position: relative;
    transition: all 0.3s ease;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
}

@keyframes kids-rainbow-text {
    0% { color: #c0392b; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3); }
    16% { color: #d68910; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3); }
    33% { color: #d4ac0d; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3); }
    50% { color: #1e8449; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3); }
    66% { color: #2874a6; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3); }
    83% { color: #7d3c98; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3); }
    100% { color: #c0392b; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3); }
}

        .ticket.theme-kids .ticket-cell:not(:empty):hover {
            transform: scale(1.2) rotate(360deg);
            background: linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
        }

.ticket.theme-kids .ticket-cell.marked {
    background: linear-gradient(135deg, #5f3dc4 0%, #7048e8 100%) !important;
    color: white !important;
    border: 3px solid #4c1d95 !important;
    animation: kids-marked-spin 2s ease-in-out infinite;
    font-weight: 900 !important;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5) !important;
    font-size: 1.2rem !important;
}

        .ticket.theme-kids .ticket-cell.marked::before {
            content: '⭐';
            position: absolute;
            top: -10px;
            right: -5px;
            font-size: 1.2rem;
            animation: kids-star-twinkle 1s ease-in-out infinite;
        }

        @keyframes kids-marked-spin {
            0%, 100% {
                transform: scale(1) rotate(0deg);
                box-shadow: 0 0 20px rgba(108, 92, 231, 0.6);
            }
            50% {
                transform: scale(1.1) rotate(5deg);
                box-shadow: 0 0 30px rgba(108, 92, 231, 0.8);
            }
        }

        @keyframes kids-star-twinkle {
            0%, 100% { 
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
            50% { 
                transform: scale(1.3) rotate(180deg);
                opacity: 0.8;
            }
        }

        .ticket.theme-kids .pattern-winner {
            animation: kids-winner-celebration 1.5s ease-in-out infinite !important;
            background: linear-gradient(45deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3, #54a0ff, #ff6b6b) !important;
            background-size: 300% 300% !important;
            color: white !important;
            border: 3px solid #fff !important;
            transform: scale(1.2);
        }

        @keyframes kids-winner-celebration {
            0% {
                background-position: 0% 50%;
                transform: scale(1.2) rotate(0deg);
                box-shadow: 0 0 30px rgba(255, 107, 107, 0.8);
            }
            25% {
                transform: scale(1.3) rotate(5deg);
            }
            50% {
                background-position: 100% 50%;
                transform: scale(1.35) rotate(-5deg);
                box-shadow: 0 0 40px rgba(255, 202, 87, 0.8);
            }
            75% {
                transform: scale(1.3) rotate(5deg);
            }
            100% {
                background-position: 0% 50%;
                transform: scale(1.2) rotate(0deg);
                box-shadow: 0 0 30px rgba(72, 219, 251, 0.8);
            }
        }

        /* Extra confetti for kids theme wins */
        .ticket.theme-kids .pattern-winner::after {
            content: '🎉';
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.5rem;
            animation: kids-confetti-pop 1s ease-out infinite;
        }

        @keyframes kids-confetti-pop {
            0% {
                transform: translateX(-50%) translateY(0) scale(0);
                opacity: 1;
            }
            50% {
                transform: translateX(-50%) translateY(-20px) scale(1.5);
                opacity: 1;
            }
            100% {
                transform: translateX(-50%) translateY(-30px) scale(0);
                opacity: 0;
            }
        }
/* Stargazer Theme */
.ticket.theme-stargazer {
    background: linear-gradient(135deg, #0a0e27 0%, #1a1a3e 25%, #16213e 50%, #0f2027 75%, #0a0e27 100%);
    border: 2px solid transparent;
    position: relative;
    overflow: visible;
    box-shadow: 0 0 50px rgba(147, 51, 234, 0.3),
                0 0 100px rgba(59, 130, 246, 0.2),
                inset 0 0 50px rgba(147, 51, 234, 0.1);
}

/* Animated border gradient */
.ticket.theme-stargazer::before {
    content: '';
    position: absolute;
    top: -2px; right: -2px; bottom: -2px; left: -2px;
    background: linear-gradient(45deg, #9333ea, #3b82f6, #06b6d4, #10b981, #f59e0b, #ef4444, #9333ea);
    background-size: 400% 400%;
    border-radius: var(--radius);
    z-index: -1;
    animation: stargazer-border 15s ease infinite;
    opacity: 0.8;
}

@keyframes stargazer-border {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

/* Stars background */
.ticket.theme-stargazer::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-image: 
        radial-gradient(2px 2px at 20px 30px, white, transparent),
        radial-gradient(2px 2px at 40px 70px, white, transparent),
        radial-gradient(1px 1px at 50px 160px, white, transparent),
        radial-gradient(1px 1px at 130px 40px, white, transparent),
        radial-gradient(2px 2px at 80px 10px, white, transparent),
        radial-gradient(1px 1px at 110px 90px, white, transparent),
        radial-gradient(1px 1px at 150px 120px, white, transparent);
    background-repeat: repeat;
    background-size: 200px 200px;
    animation: stargazer-stars 120s linear infinite;
    opacity: 0.8;
    z-index: 0;
}

@keyframes stargazer-stars {
    from { transform: translateY(0); }
    to { transform: translateY(-200px); }
}

/* Shooting stars */
.ticket.theme-stargazer .shooting-star {
    position: absolute;
    top: 0;
    width: 2px;
    height: 2px;
    background: white;
    box-shadow: 0 0 6px 2px rgba(255, 255, 255, 0.8);
    animation: stargazer-shoot 3s linear infinite;
    z-index: 1;
}

.ticket.theme-stargazer .shooting-star::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100px;
    height: 2px;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.8), transparent);
    transform: translateX(-100px);
}

@keyframes stargazer-shoot {
    0% {
        transform: translateX(0) translateY(0) rotate(-45deg);
        opacity: 0;
    }
    10% {
        opacity: 1;
    }
    90% {
        opacity: 1;
    }
    100% {
        transform: translateX(300px) translateY(300px) rotate(-45deg);
        opacity: 0;
    }
}

/* Planets decoration */
.ticket.theme-stargazer .planet {
    position: absolute;
    border-radius: 50%;
    z-index: 1;
}

.ticket.theme-stargazer .planet-1 {
    width: 60px;
    height: 60px;
    background: radial-gradient(circle at 30% 30%, #ff6b6b, #c92a2a);
    top: -30px;
    right: 50px;
    box-shadow: 0 0 30px rgba(255, 107, 107, 0.6),
                inset -10px -10px 20px rgba(0, 0, 0, 0.3);
    animation: stargazer-float 6s ease-in-out infinite;
}

.ticket.theme-stargazer .planet-2 {
    width: 40px;
    height: 40px;
    background: radial-gradient(circle at 30% 30%, #4ecdc4, #0c8b8b);
    bottom: -20px;
    left: 30px;
    box-shadow: 0 0 25px rgba(78, 205, 196, 0.6),
                inset -8px -8px 15px rgba(0, 0, 0, 0.3);
    animation: stargazer-float 8s ease-in-out infinite reverse;
}

.ticket.theme-stargazer .planet-3 {
    width: 30px;
    height: 30px;
    background: radial-gradient(circle at 30% 30%, #f7b731, #c69500);
    top: 50%;
    right: -15px;
    box-shadow: 0 0 20px rgba(247, 183, 49, 0.6),
                inset -5px -5px 10px rgba(0, 0, 0, 0.3);
    animation: stargazer-float 10s ease-in-out infinite;
}

/* Saturn ring */
.ticket.theme-stargazer .planet-2::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) rotateX(60deg);
    width: 70px;
    height: 70px;
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
}

@keyframes stargazer-float {
    0%, 100% { transform: translateY(0) rotate(0deg); }
    50% { transform: translateY(-10px) rotate(5deg); }
}

/* Aurora effect */
.ticket.theme-stargazer .aurora {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 100%;
    background: linear-gradient(180deg, 
        transparent 0%,
        rgba(66, 184, 131, 0.1) 20%,
        rgba(147, 51, 234, 0.1) 40%,
        rgba(59, 130, 246, 0.1) 60%,
        transparent 100%);
    filter: blur(40px);
    animation: stargazer-aurora 15s ease-in-out infinite;
    z-index: 0;
}

@keyframes stargazer-aurora {
    0%, 100% { 
        opacity: 0.3;
        transform: translateY(0);
    }
    50% { 
        opacity: 0.6;
        transform: translateY(-20px);
    }
}

.ticket.theme-stargazer .ticket-header {
    color: #ffffff;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    text-shadow: 0 0 20px rgba(147, 51, 234, 0.8);
    position: relative;
    z-index: 2;
}

.ticket.theme-stargazer .ticket-header h3 {
    color: #ffffff;
    font-weight: 700;
    background: linear-gradient(45deg, #ffffff, #c3b1ff, #ffffff);
    background-size: 200% 200%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: stargazer-shimmer 3s ease-in-out infinite;
}

@keyframes stargazer-shimmer {
    0%, 100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
}

.ticket.theme-stargazer .ticket-cell {
    border: 1px solid rgba(255, 255, 255, 0.2);
    background: rgba(30, 41, 59, 0.6);
    color: #ffffff;
    font-weight: 600;
    font-size: 0.9375rem;
    border-radius: 0.75rem;
    backdrop-filter: blur(10px);
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
    z-index: 2;
    text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
}

/* Nebula effect in cells */
.ticket.theme-stargazer .ticket-cell::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, 
        rgba(147, 51, 234, 0.3) 0%,
        rgba(59, 130, 246, 0.2) 30%,
        transparent 70%);
    animation: stargazer-nebula 20s linear infinite;
    opacity: 0;
    transition: opacity 0.3s ease;
}

@keyframes stargazer-nebula {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.ticket.theme-stargazer .ticket-cell:not(:empty):hover {
    transform: scale(1.1);
    border-color: rgba(147, 51, 234, 0.8);
    background: rgba(147, 51, 234, 0.3);
    box-shadow: 0 0 20px rgba(147, 51, 234, 0.6),
                inset 0 0 15px rgba(255, 255, 255, 0.2);
}

.ticket.theme-stargazer .ticket-cell:not(:empty):hover::before {
    opacity: 1;
}

.ticket.theme-stargazer .ticket-cell.marked {
    background: linear-gradient(135deg, #9333ea 0%, #3b82f6 100%) !important;
    color: white !important;
    border: 2px solid rgba(255, 255, 255, 0.6) !important;
    animation: stargazer-marked-pulse 2s ease-in-out infinite;
    box-shadow: 0 0 25px rgba(147, 51, 234, 0.8),
                inset 0 0 15px rgba(255, 255, 255, 0.3);
}

@keyframes stargazer-marked-pulse {
    0%, 100% {
        transform: scale(1);
        box-shadow: 0 0 25px rgba(147, 51, 234, 0.8),
                    0 0 50px rgba(59, 130, 246, 0.4),
                    inset 0 0 15px rgba(255, 255, 255, 0.3);
    }
    50% {
        transform: scale(1.05);
        box-shadow: 0 0 35px rgba(147, 51, 234, 1),
                    0 0 70px rgba(59, 130, 246, 0.6),
                    inset 0 0 20px rgba(255, 255, 255, 0.4);
    }
}

/* Comet trail for marked cells */
.ticket.theme-stargazer .ticket-cell.marked::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 100%;
    height: 100%;
    background: radial-gradient(circle, 
        rgba(255, 255, 255, 0.8) 0%,
        rgba(255, 255, 255, 0.4) 20%,
        transparent 60%);
    animation: stargazer-comet 3s ease-in-out infinite;
    pointer-events: none;
}

@keyframes stargazer-comet {
    0%, 100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0);
    }
    50% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.5);
    }
}

/* Pattern winner with cosmic explosion */
.ticket.theme-stargazer .pattern-winner {
    animation: stargazer-cosmic-win 2s ease-in-out infinite !important;
    background: linear-gradient(45deg, #fbbf24, #f59e0b, #ef4444, #ec4899, #9333ea, #3b82f6, #06b6d4, #fbbf24) !important;
    background-size: 400% 400% !important;
    color: white !important;
    border: 3px solid white !important;
    z-index: 10;
}

@keyframes stargazer-cosmic-win {
    0% {
        background-position: 0% 50%;
        transform: scale(1) rotate(0deg);
        box-shadow: 0 0 30px rgba(251, 191, 36, 0.8),
                    0 0 60px rgba(147, 51, 234, 0.6),
                    0 0 90px rgba(59, 130, 246, 0.4);
    }
    25% {
        transform: scale(1.1) rotate(5deg);
    }
    50% {
        background-position: 100% 50%;
        transform: scale(1.15) rotate(-5deg);
        box-shadow: 0 0 40px rgba(251, 191, 36, 1),
                    0 0 80px rgba(147, 51, 234, 0.8),
                    0 0 120px rgba(59, 130, 246, 0.6);
    }
    75% {
        transform: scale(1.1) rotate(5deg);
    }
    100% {
        background-position: 0% 50%;
        transform: scale(1) rotate(0deg);
        box-shadow: 0 0 30px rgba(251, 191, 36, 0.8),
                    0 0 60px rgba(147, 51, 234, 0.6),
                    0 0 90px rgba(59, 130, 246, 0.4);
    }
}
/* Quantum Matrix Theme */
.ticket.theme-quantum {
    background: #000;
    border: 2px solid transparent;
    position: relative;
    overflow: hidden;
    font-family: 'Courier New', monospace;
}

/* Animated matrix border */
.ticket.theme-quantum::before {
    content: '';
    position: absolute;
    top: -2px; right: -2px; bottom: -2px; left: -2px;
    background: linear-gradient(45deg, #00ff00, #00ffff, #ff00ff, #ffff00, #00ff00);
    background-size: 400% 400%;
    border-radius: var(--radius);
    z-index: -1;
    animation: quantum-border 3s linear infinite;
    filter: blur(3px);
}

@keyframes quantum-border {
    0% { background-position: 0% 50%; }
    100% { background-position: 100% 50%; }
}

/* Matrix rain background */
.ticket.theme-quantum::after {
    content: '01001000101110010110111001010101110101010011101';
    position: absolute;
    top: -100%;
    left: 0;
    width: 100%;
    height: 300%;
    font-size: 10px;
    color: #00ff00;
    opacity: 0.1;
    overflow: hidden;
    word-break: break-all;
    animation: matrix-rain 20s linear infinite;
    z-index: -1;
    pointer-events: none; /* Critical: prevent blocking clicks */
}

@keyframes matrix-rain {
    from { transform: translateY(0); }
    to { transform: translateY(100%); }
}

/* Glitch effect containers */
.ticket.theme-quantum .glitch-layer {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: inherit;
    z-index: -1;
}

.ticket.theme-quantum .ticket-header {
    color: #00ff00;
    border-bottom: 1px solid #00ff00;
    text-transform: uppercase;
    position: relative;
    z-index: 2;
    animation: quantum-glitch 5s infinite;
}
.ticket.theme-quantum .ticket-grid {
    position: relative;
    z-index: 10; /* Ensure grid is above all effects */
}

@keyframes quantum-glitch {
    0%, 100% { 
        text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00;
        transform: translate(0);
    }
    5% {
        text-shadow: -2px 0 #ff00ff, 2px 0 #00ffff;
        transform: translate(2px, -2px);
    }
    10% {
        text-shadow: 2px 0 #ff00ff, -2px 0 #00ffff;
        transform: translate(-2px, 2px);
    }
    15% {
        text-shadow: 0 0 5px #00ff00, 0 0 10px #00ff00;
        transform: translate(0);
    }
}

.ticket.theme-quantum .ticket-header h3 {
    color: #00ff00;
    font-weight: 700;
    letter-spacing: 2px;
}

.ticket.theme-quantum .ticket-cell {
    border: 1px solid #003300;
    background: rgba(0, 0, 0, 0.8);
    color: #00ff00;
    font-weight: bold;
    border-radius: 0;
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
    font-size: 0.9rem;
}

/* Quantum probability cloud effect */
.ticket.theme-quantum .ticket-cell::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: radial-gradient(circle, rgba(0, 255, 255, 0.8) 0%, transparent 70%);
    transition: all 0.3s ease;
    transform: translate(-50%, -50%);
    pointer-events: none; /* Prevent blocking clicks */
    z-index: -1;
}

.ticket.theme-quantum .ticket-cell:not(:empty):hover {
    background: rgba(0, 255, 0, 0.2);
    border-color: #00ffff;
    color: #00ffff;
    transform: scale(1.1);
    z-index: 10;
    cursor: pointer;
}

.ticket.theme-quantum .ticket-cell:not(:empty):hover::before {
    width: 200%;
    height: 200%;
}

/* Marked cells - quantum entangled state */
.ticket.theme-quantum .ticket-cell.marked {
    background: rgba(0, 255, 0, 0.3) !important;
    color: #00ff00 !important; /* Keep original color visible */
    border: 2px solid #00ff00 !important;
    animation: quantum-marked 2s ease-in-out infinite;
    position: relative;
    font-weight: bold !important;
    text-shadow: 0 0 10px #00ff00, 0 0 20px #00ff00;
}

.ticket.theme-quantum .ticket-cell.marked::after {
    content: attr(data-num);
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 1.2rem;
    font-weight: bold;
    background: linear-gradient(45deg, #00ff00, #00ffff, #ff00ff, #ffff00);
    background-size: 200% 200%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: quantum-text 3s ease-in-out infinite;
    pointer-events: none; /* This makes the pseudo-element not block clicks */
    z-index: 1;
}

@keyframes quantum-marked {
    0%, 100% {
        box-shadow: 
            0 0 10px #00ff00,
            0 0 20px #00ffff,
            0 0 30px #ff00ff,
            inset 0 0 20px rgba(0, 255, 0, 0.2);
    }
    33% {
        box-shadow: 
            0 0 15px #ff00ff,
            0 0 25px #ffff00,
            0 0 35px #00ff00,
            inset 0 0 20px rgba(255, 0, 255, 0.2);
    }
    66% {
        box-shadow: 
            0 0 15px #00ffff,
            0 0 25px #00ff00,
            0 0 35px #ff00ff,
            inset 0 0 20px rgba(0, 255, 255, 0.2);
    }
}

@keyframes quantum-text {
    0% { background-position: 0% 50%; }
    100% { background-position: 200% 50%; }
}

/* Pattern winner - quantum collapse */
.ticket.theme-quantum .pattern-winner {
    animation: quantum-collapse 1.5s ease-in-out infinite !important;
}

@keyframes quantum-collapse {
    0%, 100% {
        background: rgba(0, 255, 0, 0.8) !important;
        transform: scale(1) rotate(0deg);
        box-shadow: 
            0 0 30px #00ff00,
            0 0 60px #00ffff,
            0 0 90px #ff00ff;
    }
    25% {
        transform: scale(1.2) rotate(90deg);
    }
    50% {
        background: rgba(255, 0, 255, 0.8) !important;
        transform: scale(0.8) rotate(180deg);
        box-shadow: 
            0 0 40px #ff00ff,
            0 0 80px #ffff00,
            0 0 120px #00ff00;
    }
    75% {
        transform: scale(1.1) rotate(270deg);
    }
}

/* Quantum particles floating */
.ticket.theme-quantum .quantum-particle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: #00ff00;
    border-radius: 50%;
    box-shadow: 0 0 10px #00ff00;
    animation: quantum-float 10s infinite linear;
    pointer-events: none; /* Prevent blocking clicks */
    z-index: 5; /* Below the grid */
}

@keyframes quantum-float {
    0% {
        transform: translate(0, 100vh) rotate(0deg);
        opacity: 0;
    }
    10% {
        opacity: 1;
    }
    90% {
        opacity: 1;
    }
    100% {
        transform: translate(200px, -100vh) rotate(720deg);
        opacity: 0;
    }
}
/* Jungle Theme */
.ticket.theme-jungle {
    background: #f5f5dc;
    border: 2px solid #8b7355;
    position: relative;
    overflow: visible;
    transition: all 0.5s ease;
}

.ticket.theme-jungle .ticket-header {
    color: #5d4e37;
    border-bottom-color: #8b7355;
}

.ticket.theme-jungle .ticket-header h3 {
    color: #5d4e37;
}

.ticket.theme-jungle .ticket-cell {
    border: 1px solid #a0826d;
    background: #faf0e6;
    color: #5d4e37;
    font-weight: 600;
    border-radius: 0.5rem;
    transition: all 0.3s ease;
}

.ticket.theme-jungle .ticket-cell:not(:empty):hover {
    transform: scale(1.05);
    background: #f0e68c;
    border-color: #8b7355;
}

.ticket.theme-jungle .ticket-cell.marked {
    background: #90ee90 !important;
    color: #2e7d32 !important;
    border-color: #228b22 !important;
}

.jungle-creature {
    position: absolute;
    font-size: 2rem;
    animation: jungleFloat 3s ease-in-out infinite;
    pointer-events: none;
    z-index: 5;
}

@keyframes jungleFloat {
    0%, 100% { transform: translateY(0) rotate(0deg); }
    50% { transform: translateY(-10px) rotate(5deg); }
}

.jungle-bird {
    animation: jungleFly 8s linear infinite;
}

@keyframes jungleFly {
    0% { transform: translateX(-50px) translateY(0); }
    25% { transform: translateX(100px) translateY(-20px); }
    50% { transform: translateX(200px) translateY(10px); }
    75% { transform: translateX(100px) translateY(-15px); }
    100% { transform: translateX(-50px) translateY(0); }
}

.jungle-butterfly {
    animation: butterflyDance 4s ease-in-out infinite;
}

@keyframes butterflyDance {
    0% { transform: rotate(0deg) translateX(0) translateY(0); }
    25% { transform: rotate(10deg) translateX(20px) translateY(-10px); }
    50% { transform: rotate(-10deg) translateX(-20px) translateY(-20px); }
    75% { transform: rotate(5deg) translateX(10px) translateY(-10px); }
    100% { transform: rotate(0deg) translateX(0) translateY(0); }
}

.ticket.theme-jungle.jungle-growing {
    background: linear-gradient(to bottom, #87ceeb 0%, #98fb98 50%, #228b22 100%);
}

.ticket.theme-jungle.jungle-full {
    background: linear-gradient(to bottom, #87ceeb 0%, #3cb371 30%, #228b22 60%, #006400 100%);
    box-shadow: 0 0 30px rgba(34, 139, 34, 0.3);
}

.jungle-foliage {
    position: absolute;
    bottom: -5px;
    left: -5px;
    right: -5px;
    height: 0;
    background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 20"><path d="M0,20 Q5,0 10,20 T20,20 T30,20 T40,20 T50,20 T60,20 T70,20 T80,20 T90,20 T100,20" fill="%23228b22"/></svg>') repeat-x;
    transition: height 0.5s ease;
    z-index: 4;
}

.ticket.theme-jungle.jungle-growing .jungle-foliage {
    height: 20px;
}

.ticket.theme-jungle.jungle-full .jungle-foliage {
    height: 40px;
}

@keyframes rotate {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

@keyframes fadeIn {
    from { opacity: 0; transform: scale(0.5); }
    to { opacity: 1; transform: scale(1); }
}
        /* Team storage section */
        .team-storage-section {
            background: #f9fafb;
            padding: 1rem;
            border-radius: var(--radius);
            margin-top: 1rem;
            border: 1px solid var(--border);
        }

        .team-storage-section h4 {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
        }

        .team-storage-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .team-storage-controls input {
            width: 100px;
        }

        .team-storage-controls label {
            font-size: 0.8125rem;
            color: var(--text-secondary);
        }

        /* Group message styles */
        .group-message-container {
            max-height: 400px;
            overflow-y: auto;
            background: #f9fafb;
            padding: 1rem;
            border-radius: var(--radius);
            border: 1px solid var(--border);
            font-family: monospace;
            font-size: 0.875rem;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Rage click section */
        .rage-click-section {
            background: linear-gradient(to bottom right, #fef3c7, #fed7aa);
            padding: 1rem;
            border-radius: var(--radius);
            margin-top: 1rem;
            border: 1px solid #fbbf24;
        }

        .rage-click-section h4 {
            font-size: 0.875rem;
            font-weight: 600;
            color: #92400e;
            margin-bottom: 0.75rem;
        }

        .rage-click-controls {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .rage-click-controls input[type="checkbox"] {
            width: 1.25rem;
            height: 1.25rem;
            accent-color: #f59e0b;
        }

        .rage-click-controls select {
            padding: 0.5rem;
            border: 1px solid #f59e0b;
            border-radius: 0.5rem;
            font-size: 0.875rem;
        }

        .rage-click-controls label {
            font-size: 0.8125rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .pass-keys-display {
            margin-top: 1rem;
            padding: 1rem;
            background: white;
            border-radius: 0.5rem;
            border: 1px solid var(--border);
        }

        .pass-keys-display h5 {
            font-size: 0.875rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .pass-key-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
            font-size: 0.8125rem;
        }

        .pass-key-item:last-child {
            border-bottom: none;
        }

        .pass-key {
            font-weight: 600;
            font-family: monospace;
            font-size: 1rem;
            color: var(--primary);
        }

        /* Animations */
        @keyframes slideDown {
            0% {
                transform: translateX(-50%) translateY(-100%);
                opacity: 0;
            }
            20% {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
            80% {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
            100% {
                transform: translateX(-50%) translateY(-100%);
                opacity: 0;
            }
        }

        /* Mobile optimizations */
        @media (max-width: 480px) {
            .container {
                padding: 0.75rem;
            }

            .card {
                padding: 1.25rem;
            }

            .ticket-cell {
                font-size: 0.75rem;
            }
            
            .number-cell {
                font-size: 0.625rem;
            }

            .controls {
                grid-template-columns: 1fr;
            }

            .game-type-inputs {
                grid-template-columns: 1fr;
                padding-left: 1.5rem;
            }

            .current-number {
                font-size: 2.5rem;
            }

            .modal-content {
                padding: 1.5rem;
            }

            .voice-mode-group {
                gap: 0.5rem;
            }

            .theme-selector {
                flex-wrap: wrap;
            }

            .theme-btn {
                font-size: 0.75rem;
                padding: 0.375rem 0.75rem;
            }
            
            .too-late-notification {
                padding: 0.75rem 1.5rem;
                min-width: 200px;
                max-width: 300px;
            }
            
            .too-late-notification h3 {
                font-size: 1rem;
            }
            
            .too-late-notification p {
                font-size: 0.75rem;
            }
            
            .too-late-notification p strong {
                font-size: 0.875rem;
            }
        }

        /* Smooth scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: var(--secondary);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--text-secondary);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-primary);
        }

        /* Loading state */
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        /* Focus visible */
        *:focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎱 Housie Game</h1>
        </div>

        <!-- Landing Page -->
        <div id="landingPage" class="card">
            <h2 style="text-align: center;">Welcome to Housie!</h2>
            <button class="btn btn-primary" onclick="showAdminSetup()">Start New Game (Admin)</button>
            <button class="btn btn-secondary" onclick="showJoinGame()">Join Game (Player)</button>
            <button class="btn btn-secondary" onclick="resumeAdmin()">Resume Game (Admin)</button>
            <button class="btn btn-secondary" onclick="startWithSameTeam()" id="sameTeamBtn" style="display: none;">Start with Same Team & Settings</button>
        </div>

        <!-- Admin Setup -->
        <div id="adminSetup" class="card hidden">
            <h2>Game Setup</h2>
            
            <div class="sequence-setup">
                <h3>Game Mode</h3>
                <div class="sequence-mode-toggle">
                    <label>
    <input type="radio" name="sequenceMode" value="random" checked onchange="toggleSequenceMode()">
    Random (Traditional)
</label>
<label>
    <input type="radio" name="sequenceMode" value="predetermined" onchange="toggleSequenceMode()">
    Predetermined
</label>
<label>
    <input type="radio" name="sequenceMode" value="manual" onchange="toggleSequenceMode()">
    Manual Claims
</label>
                </div>
                <div id="predeterminedInfo" style="display: none;">
                    <p style="font-size: 0.8125rem; color: #92400e; margin-top: 0.5rem;">
                        The system will automatically determine winners based on player tickets. Winners will be displayed below after generating tickets.
                    </p>
                </div>
                <div id="manualInfo" style="display: none;">
                    <p style="font-size: 0.8125rem; color: #92400e; margin-top: 0.5rem;">
                        Players can manually claim wins through buttons. Winners are awarded on first-come basis.
                    </p>
                </div>
            </div>
<div class="distribution-setup" style="display: none;">
    <h3>Winner Distribution <span class="info-icon" onclick="showDistributionInfo()">i</span></h3>
    <div class="distribution-mode-toggle">
        <label>
            <input type="radio" name="winnerDistribution" value="random" checked>
            <div>
                <strong>Completely Random</strong>
                <div class="distribution-description">Traditional mode - winners are determined naturally. Some players might not win any games.</div>
            </div>
        </label>
        <label>
            <input type="radio" name="winnerDistribution" value="majority">
            <div>
                <strong>Majority Winners</strong>
                <div class="distribution-description">60-70% of players will win at least one game. Ensures most players experience winning.</div>
            </div>
        </label>
        <label>
            <input type="radio" name="winnerDistribution" value="everyone">
            <div>
                <strong>Almost Everyone Wins</strong>
                <div class="distribution-description">Every player wins at least one game. Best for family gatherings and inclusive fun.</div>
            </div>
        </label>
    </div>
</div>
            
            <div class="kitty-section">
                <h3>Prize Pool Setup</h3>
                <div class="input-group">
                    <label id="kittyLabel">Total Kitty Amount (₹):</label>
                    <input type="number" id="kittyAmount" min="0" value="1000" onchange="updatePrizeDistribution()">
                </div>
                <div class="input-group">
                    <label>Distribution Mode:</label>
                    <select id="distributionMode" onchange="toggleDistributionMode()">
                        <option value="percentage">Percentage Based</option>
                        <option value="manual">Manual Entry</option>
                    </select>
                </div>
            </div>

            <div class="input-group">
                <label>Select Game Types & Configure Prizes:</label>
                <div id="gameTypesContainer">
                    <!-- Game types will be added here by JavaScript -->
                </div>
                <div class="kitty-total" id="totalDistributed">Total Distributed: ₹0</div>
            </div>

            <div class="input-group">
                <label>Number of Players:</label>
                <input type="number" id="playerCount" min="2" max="50" value="4">
            </div>

            <div class="input-group">
                <label>Popup Duration (seconds):</label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                    <div>
                        <label style="font-size: 0.8125rem; color: var(--text-secondary);">Admin Screen</label>
                        <input type="number" id="adminPopupDuration" min="1" max="30" value="5">
                    </div>
                    <div>
                        <label style="font-size: 0.8125rem; color: var(--text-secondary);">Player Screen</label>
                        <input type="number" id="playerPopupDuration" min="1" max="30" value="5">
                    </div>
                </div>
                <small style="color: var(--text-secondary); font-size: 0.75rem; display: block; margin-top: 0.5rem;">Controls how long winner/late popups stay on screen</small>
            </div>

            <div class="input-group">
                <label>Pattern Glow Duration (seconds):</label>
                <input type="number" id="glowDuration" min="1" max="30" value="5">
                <small style="color: var(--text-secondary); font-size: 0.75rem; display: block; margin-top: 0.5rem;">Controls how long winning patterns glow on tickets</small>
            </div>

<div class="input-group">
    <label>Notification Theme:</label>
    <select id="notificationTheme">
        <option value="default">Default (Green)</option>
        <option value="neon">Neon Glow</option>
        <option value="royal">Royal Gold</option>
        <option value="aurora">Aurora Borealis</option>
        <option value="matrix">Matrix Digital</option>
    </select>
    <small style="color: var(--text-secondary); font-size: 0.75rem; display: block; margin-top: 0.5rem;">Controls the appearance of winner notifications</small>
</div>

<div class="input-group">
    <label>Celebration Effect:</label>
    <select id="celebrationEffect">
        <option value="confetti">Confetti (Default)</option>
        <option value="fireworks">Fireworks</option>
        <option value="starburst">Starburst</option>
    </select>
    <small style="color: var(--text-secondary); font-size: 0.75rem; display: block; margin-top: 0.5rem;">Visual effect shown when someone wins</small>
</div>


            <div class="input-group">
                <label>Enable Confetti Celebrations:</label>
                <div style="display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.5rem; padding-left: 1rem;">
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="checkbox" id="confettiPlayer" checked style="margin-right: 0.5rem; width: 1.25rem; height: 1.25rem; accent-color: var(--primary);">
                        Show confetti on player screens when they win
                    </label>
                    <label style="display: flex; align-items: center; font-weight: normal; cursor: pointer;">
                        <input type="checkbox" id="confettiAdmin" checked style="margin-right: 0.5rem; width: 1.25rem; height: 1.25rem; accent-color: var(--primary);">
                        Show confetti on admin screen for wins
                    </label>
                </div>
            </div>

            <div class="input-group">
                <label>Player Ticket Cache Duration (minutes):</label>
                <input type="number" id="cacheDuration" min="0" max="1440" value="30">
                <small style="color: var(--text-secondary); font-size: 0.75rem; display: block; margin-top: 0.5rem;">Preserves marked numbers if player refreshes (0 = no caching)</small>
            </div>

<div class="input-group">
    <label>Ticket Link Validity:</label>
    <div style="display: flex; gap: 1rem; align-items: center;">
        <div style="flex: 1;">
            <input type="number" id="ticketExpiry" min="0" max="720" value="24" style="width: 100%;">
        </div>
        <div style="flex: 1;">
            <select id="ticketExpiryUnit" style="width: 100%;">
                <option value="hours" selected>Hours</option>
                <option value="minutes">Minutes</option>
            </select>
        </div>
    </div>
    <small style="color: var(--text-secondary); font-size: 0.75rem; display: block; margin-top: 0.5rem;">
        How long ticket links remain valid after generation (0 = never expire)
    </small>
</div>
            <div class="rage-click-section">
                <h4>Rage Click Protection</h4>
                <div class="rage-click-controls">
                    <label>
                        <input type="checkbox" id="rageClickEnabled" checked onchange="updateRageClickDisplay()">
                        Enable rage click detection
                    </label>
                    <label>
                        Max clicks per second:
                        <select id="rageClickThreshold">
                            <option value="1">1</option>
                            <option value="2">2</option>
                            <option value="3" selected>3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                        </select>
                    </label>
                </div>
                <small style="color: #92400e; font-size: 0.75rem; display: block; margin-top: 0.5rem;">
                    Prevents players from marking numbers too quickly without listening to announcements
                </small>
                <div id="passKeysDisplay" class="pass-keys-display" style="display: none;">
                    <h5>Pass Keys for Unlock:</h5>
                    <div class="pass-key-item">
                        <span>First Warning:</span>
                        <span class="pass-key" id="passKey1">-</span>
                    </div>
                    <div class="pass-key-item">
                        <span>Second Warning:</span>
                        <span class="pass-key" id="passKey2">-</span>
                    </div>
                </div>
            </div>

            <div class="team-storage-section">
                <h4>Store Team & Game Settings</h4>
                <div class="team-storage-controls">
                    <input type="checkbox" id="storeTeam" style="width: auto; margin-right: 0.5rem;">
                    <label for="storeTeam">Store complete setup for</label>
                    <input type="number" id="storeHours" min="0" max="24" value="0" style="margin: 0 0.5rem;">
                    <label>hours</label>
                </div>
                <small style="color: var(--text-secondary); font-size: 0.75rem; display: block; margin-top: 0.5rem;">Stores players, games, prizes, and all settings</small>
            </div>

            <button class="btn btn-primary" onclick="setupPlayers()">Next: Add Players</button>
            <button class="btn btn-secondary" onclick="showLanding()">Back</button>
        </div>

        <!-- Player Registration -->
        <div id="playerRegistration" class="card hidden">
            <h2>Add Players</h2>
            <div id="playerInputs"></div>
            <button class="btn btn-primary" onclick="startGame()">Generate Tickets & Start</button>
            <button class="btn btn-secondary" onclick="showAdminSetup(true)">Back</button>
        </div>

        <!-- Admin Dashboard -->

        <div id="adminDashboard" class="card hidden">
            <h2 style="text-align: center;">Admin Dashboard</h2>
<button class="show-winners-btn" onclick="toggleWinnersList()" style="display: none;" id="showWinnersBtn">!</button>
            
            <div id="predeterminedWinnersDisplay" class="predetermined-winners-section" style="display: none;">
                <h3 style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.75rem;">Predetermined Winners</h3>
                <div id="predeterminedWinnersList"></div>
            </div>
            
            <div class="game-status">
                <div style="font-size: 0.875rem; color: var(--text-secondary);">Called Numbers: <span id="calledCount">0</span>/90</div>
                <div class="current-number" id="currentNumber">--</div>
                <div id="lastNumbers" style="font-size: 0.8125rem; color: var(--text-secondary);"></div>
            </div>

            <div class="controls">
                <button class="btn btn-primary" onclick="callNumber()">Call Number</button>
                <button class="btn btn-secondary" onclick="toggleAutoPlay()">
                    <span id="autoPlayText">Auto Play</span>
                </button>
            </div>

            <div class="input-group">
                <label>Voice Settings:</label>
                <select id="voiceSelect" onchange="updateVoiceSettings()">
                    <!-- Voice options will be populated dynamically -->
                </select>
                <div class="voice-mode-group">
                    <label>
                        <input type="radio" name="voiceMode" value="number" checked>
                        Number only (e.g., "42")
                    </label>
                    <label>
                        <input type="radio" name="voiceMode" value="words">
                        In words (e.g., "four two")
                    </label>
                    <label>
                        <input type="radio" name="voiceMode" value="full">
                        Full style (e.g., "four two forty-two")
                    </label>
                </div>
            </div>

            <div class="input-group">
                <label>Auto Play Interval (seconds):</label>
                <input type="number" id="autoInterval" min="3" max="30" value="5">
            </div>

            <div class="number-board" id="numberBoard"></div>
            
            <div id="rageClickPassKeys" class="pass-keys-display" style="display: none; margin-top: 1rem;">
                <h5 style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.5rem;">Rage Click Pass Keys:</h5>
                <div class="pass-key-item">
                    <span>First Warning:</span>
                    <span class="pass-key" id="passKey1Dashboard">-</span>
                </div>
                <div class="pass-key-item">
                    <span>Second Warning:</span>
                    <span class="pass-key" id="passKey2Dashboard">-</span>
                </div>
            </div>

            <button class="btn btn-success" onclick="showWinners()">View Winners</button>
            <button class="btn btn-secondary" onclick="showPlayers()">View Players</button>
            <button class="btn btn-danger" onclick="endGame()">End Game</button>
        </div>

        <!-- Player View -->
        <div id="playerView" class="hidden">
            <div class="card">
                <h2 style="text-align: center;" id="playerName"></h2>
                <div id="playerTicket"></div>
                <div id="winStatus" style="text-align: center; margin-top: 1.5rem;"></div>
            </div>
        </div>

        <!-- Join Game -->
        <div id="joinGame" class="card hidden">
            <h2>Join Game</h2>
            <div class="input-group">
                <label>Enter Your Phone Number:</label>
                <input type="tel" id="joinPhone" placeholder="Enter phone number">
            </div>
            <button class="btn btn-primary" onclick="joinWithPhone()">View My Ticket</button>
            <button class="btn btn-secondary" onclick="showLanding()">Back</button>
        </div>

        <!-- Modals -->
        <div id="winnersModal" class="modal">
            <div class="modal-content">
                <h2>Winners</h2>
                <div id="winnersList"></div>
                <div id="winnersSummary" class="winner-summary">
                    <h3>Player-wise Summary</h3>
                    <div id="winnersSummaryList"></div>
                </div>
            <button class="btn btn-warning" onclick="shareWinningSummary()">Share Summary on WhatsApp</button>
<button class="btn btn-primary" onclick="showSettlementCalculator()">Settlement Without Deposit</button>
<button class="btn btn-secondary" onclick="closeModal('winnersModal')">Close</button>
            </div>
        </div>

        <div id="playersModal" class="modal">
            <div class="modal-content">
                <h2>Players</h2>
                <div id="playersList" class="player-list"></div>
                <button class="btn btn-secondary" onclick="closeModal('playersModal')">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Game state
        let gameState = {
            gameTypes: [],
            players: [],
            calledNumbers: [],
            winners: {},
            isAutoPlay: false,
            autoPlayInterval: null,
            tickets: {},
            prizes: {},
            kittyAmount: 1000,
            distributionMode: 'percentage',
            glowDuration: 5,
            confettiPlayer: true,
            confettiAdmin: true,
            sequenceMode: 'random',
            predeterminedSequence: [],
            predeterminedWinners: {},
            cacheDuration: 30,
            rageClickEnabled: true,
            rageClickThreshold: 3,
            passKey1: '',
            passKey2: ''
        };

        // Track manually edited percentages
        let manuallyEditedPercentages = new Set();

        // Rage click tracking - store per phone to avoid conflicts
        let rageClickData = {};
        let rageClickWarnings = {};
// Notification tracking
let activeNotifications = [];

// Add notification to stack
function addNotificationToStack(notification) {
    // Calculate position based on existing notifications
    const existingHeight = activeNotifications.reduce((total, notif) => {
        const height = notif.offsetHeight || 60; // Default height if not yet rendered
        return total + height + 10; // 10px gap between notifications
    }, 0);
    
    // Set bottom position
    notification.style.bottom = (20 + existingHeight) + 'px';
    
    // Add to tracking array
    activeNotifications.push(notification);
    
    // Force reflow to ensure proper positioning
    notification.offsetHeight;
}

// Remove notification from stack and adjust others
function removeNotificationFromStack(notification) {
    const index = activeNotifications.indexOf(notification);
    if (index > -1) {
        activeNotifications.splice(index, 1);
        
        // Recalculate positions for remaining notifications
        let currentBottom = 20;
        activeNotifications.forEach(notif => {
            notif.style.transition = 'all 0.3s ease';
            notif.style.bottom = currentBottom + 'px';
            currentBottom += notif.offsetHeight + 10;
        });
    }
}

        // Generate random 4-digit pass key
        function generatePassKey() {
            return Math.floor(1000 + Math.random() * 9000).toString();
        }

        // URL Shortening Functions
        function encodeTicketData(data) {
            try {
                // Step 1: Optimize structure
                const optimized = {
                    n: data.name,
                    p: data.phone,
                    // Encode ticket as position:number pairs
                    t: [],
                    // Game IDs as indices
                    g: data.games.map(g => allGameTypes.findIndex(gt => gt.id === g)).join(','),
                    // Prizes in same order as games
                    z: data.games.map(g => data.prizes[g]).join(','),
                    // Add sequence mode
                    m: data.sequenceMode || 'random',
                    // Add rage click settings
                    r: data.rageClickEnabled ? `${data.rageClickThreshold}` : '0',
                    // Add pass keys if rage click is enabled
                    k1: data.rageClickEnabled ? data.passKey1 : '',
                    k2: data.rageClickEnabled ? data.passKey2 : '',
                 ex: data.expiryTime ? Math.floor(data.expiryTime / 60000) : 0,  // Store absolute time in minutes since epoch
    nt: data.notificationTheme || 'default',  
    ce: data.celebrationEffect || 'confetti',
pd: data.playerPopupDuration || 5
                };
                
                // Encode ticket positions efficiently
                data.ticket.forEach((row, r) => {
                    row.forEach((num, c) => {
                        if (num > 0) {
                            optimized.t.push(`${r*9+c}:${num}`);
                        }
                    });
                });
                optimized.t = optimized.t.join(',');
                
                // Handle predetermined data if present
                if (data.sequenceMode === 'predetermined' && data.predeterminedSequence && data.predeterminedSequence.length > 0) {
                    // Encode sequence using run-length encoding for consecutive numbers
                    const seq = data.predeterminedSequence;
                    let encoded = [seq[0]];
                    
                    for (let i = 1; i < seq.length; i++) {
                        const diff = seq[i] - seq[i-1];
                        if (diff === 1) {
                            // Count consecutive increments
                            let count = 1;
                            while (i + count < seq.length && seq[i + count] - seq[i + count - 1] === 1) {
                                count++;
                            }
                            encoded.push(`+${count}`);
                            i += count - 1;
                        } else {
                            encoded.push(diff);
                        }
                    }
                    optimized.s = encoded.join(',');
                    
                    // Encode winners (game index:player index:number)
                const winners = [];
data.games.forEach((gameId, idx) => {
    const winner = data.predeterminedWinners[gameId];
    if (winner) {
        // Include all winners if available
        const winnerNames = winner.allWinners ? winner.allWinners.join('|') : winner.winner;
        winners.push(`${idx}:${winnerNames}:${winner.winningNumber}`);
    }
});
                    if (winners.length > 0) {
                        optimized.w = winners.join('!');
                    }
                }
                
                // Step 2: Compress with maximum compression
                const jsonStr = JSON.stringify(optimized);
                const compressed = pako.deflate(jsonStr, { level: 9 });
                
                // Step 3: Convert to base64
                return btoa(String.fromCharCode.apply(null, compressed))
                    .replace(/\+/g, '-')  // URL-safe encoding
                    .replace(/\//g, '_')
                    .replace(/=/g, '');   // Remove padding
                    
            } catch (e) {
                console.error('Error encoding ticket data:', e);
                // Fallback to original encoding
                return btoa(JSON.stringify(data));
            }
        }
        
        function decodeTicketData(encoded) {
            try {
                // Try new compressed format first
                const base64 = encoded
                    .replace(/-/g, '+')
                    .replace(/_/g, '/')
                    .padEnd(encoded.length + (4 - encoded.length % 4) % 4, '=');
                    
                const compressed = atob(base64).split('').map(c => c.charCodeAt(0));
                const jsonStr = pako.inflate(new Uint8Array(compressed), { to: 'string' });
                const optimized = JSON.parse(jsonStr);
                
                // Reconstruct ticket
                const ticket = Array(3).fill(null).map(() => Array(9).fill(0));
                optimized.t.split(',').forEach(pair => {
                    const [pos, num] = pair.split(':').map(Number);
                    const row = Math.floor(pos / 9);
                    const col = pos % 9;
                    ticket[row][col] = num;
                });
                
                // Reconstruct games and prizes
                const gameIndices = optimized.g.split(',').map(Number);
                const games = gameIndices.map(i => allGameTypes[i].id);
                const prizeValues = optimized.z.split(',').map(Number);
                const prizes = {};
                games.forEach((game, idx) => {
                    prizes[game] = prizeValues[idx];
                });
                
                const result = {
                    name: optimized.n,
                    phone: optimized.p,
                    ticket: ticket,
                    games: games,
                    prizes: prizes,
                    sequenceMode: optimized.m || 'random',
                    rageClickEnabled: optimized.r !== '0',
                    rageClickThreshold: parseInt(optimized.r) || 3,
                    passKey1: optimized.k1 || '',
                    passKey2: optimized.k2 || '',
                    expiryTime: optimized.ex ? (optimized.ex * 60000) : 0,  // Convert back to milliseconds
 notificationTheme: optimized.nt || 'default',  
    celebrationEffect: optimized.ce || 'confetti',
playerPopupDuration: optimized.pd || 5 
                };
                
                // Reconstruct predetermined data if present
                if (optimized.s && optimized.m === 'predetermined') {
                    // Decode sequence
                    const parts = optimized.s.split(',');
                    const sequence = [parseInt(parts[0])];
                    
                    for (let i = 1; i < parts.length; i++) {
                        if (parts[i].startsWith('+')) {
                            // Handle consecutive increments
                            const count = parseInt(parts[i].substring(1));
                            for (let j = 0; j < count; j++) {
                                sequence.push(sequence[sequence.length - 1] + 1);
                            }
                        } else {
                            sequence.push(sequence[sequence.length - 1] + parseInt(parts[i]));
                        }
                    }
                    result.predeterminedSequence = sequence;
                    
                    // Decode winners
result.predeterminedWinners = {};
if (optimized.w) {
    optimized.w.split('!').forEach(entry => {  // Changed from | to ! to avoid conflict
        const [gameIdx, winners, number] = entry.split(':');
        const gameId = games[parseInt(gameIdx)];
        const winnerList = winners.split('|');  // Split multiple winners
        
        result.predeterminedWinners[gameId] = {
            winner: winnerList[0],  // First winner for compatibility
            winningNumber: parseInt(number),
            allWinners: winnerList,  // All winners array
            splitBetween: winnerList.length
        };
    });
}
                }
                
                return result;
                
            } catch (e) {
                console.error('Error decoding compressed data, trying fallback:', e);
                // Fallback to original decoding
                try {
                    return JSON.parse(atob(encoded));
                } catch (e2) {
                    console.error('Fallback decoding also failed:', e2);
                    return null;
                }
            }
        }
        
        // Winners data compression functions
        function encodeWinnersData(data) {
            try {
                const jsonStr = JSON.stringify(data);
                const compressed = pako.deflate(jsonStr, { level: 9 });
                return btoa(String.fromCharCode.apply(null, compressed))
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_')
                    .replace(/=/g, '');
            } catch (e) {
                console.error('Error encoding winners data:', e);
                return btoa(JSON.stringify(data));
            }
        }
        
        function decodeWinnersData(encoded) {
            try {
                const base64 = encoded
                    .replace(/-/g, '+')
                    .replace(/_/g, '/')
                    .padEnd(encoded.length + (4 - encoded.length % 4) % 4, '=');
                    
                const compressed = atob(base64).split('').map(c => c.charCodeAt(0));
                const jsonStr = pako.inflate(new Uint8Array(compressed), { to: 'string' });
                return JSON.parse(jsonStr);
            } catch (e) {
                console.error('Error decoding compressed winners data, trying fallback:', e);
                try {
                    return JSON.parse(atob(encoded));
                } catch (e2) {
                    console.error('Fallback decoding also failed:', e2);
                    return null;
                }
            }
        }

        // Pattern highlight timeout storage
        let patternTimeouts = {};

        // Number to words mapping
        const numberWords = {
            0: 'zero', 1: 'one', 2: 'two', 3: 'three', 4: 'four',
            5: 'five', 6: 'six', 7: 'seven', 8: 'eight', 9: 'nine'
        };

        // All available game types with default percentages
        const allGameTypes = [
            { id: 'firstFive', name: 'First Five', description: 'First 5 numbers on ticket', defaultPercentage: 5 },
            { id: 'lucky7', name: 'Lucky 7', description: 'First 7 numbers marked', defaultPercentage: 7 },
            { id: 'topLine', name: 'Top Line', description: 'Complete first row', defaultPercentage: 10 },
            { id: 'middleLine', name: 'Middle Line', description: 'Complete second row', defaultPercentage: 10 },
            { id: 'bottomLine', name: 'Bottom Line', description: 'Complete third row', defaultPercentage: 10 },
            { id: 'corners', name: 'Four Corners', description: 'All 4 corner numbers', defaultPercentage: 8 },
            { id: 'railwayTrack', name: 'Railway Track', description: 'Top and bottom lines complete', defaultPercentage: 8 },
            { id: 'pyramid', name: 'Pyramid', description: 'Pyramid pattern (middle 1 of top row, middle 3 of middle row, all 5 of bottom row)', defaultPercentage: 5 },
            { id: 'breakfast', name: 'Breakfast', description: 'First 3 columns complete', defaultPercentage: 5 },
            { id: 'lunch', name: 'Lunch', description: 'Middle 3 columns (4,5,6) complete', defaultPercentage: 5 },
            { id: 'dinner', name: 'Dinner', description: 'Last 3 columns complete', defaultPercentage: 5 },
            { id: 'fullHouse', name: 'Full House', description: 'All numbers on ticket (only first player wins)', defaultPercentage: 20 },
            { id: 'house1', name: 'House 1', description: 'First player to complete all numbers', defaultPercentage: 1 },
            { id: 'house2', name: 'House 2', description: 'Second player to complete all numbers', defaultPercentage: 1 },
            { id: 'firstTwoLines', name: 'First Two Lines', description: 'Complete first and second rows', defaultPercentage: 0 },
            { id: 'lastTwoLines', name: 'Last Two Lines', description: 'Complete second and third rows', defaultPercentage: 0 },
            { id: 'centerColumn', name: 'Center Column', description: 'All numbers in 5th column', defaultPercentage: 0 },
            { id: 'bullsEye', name: "Bull's Eye", description: 'Middle number of middle row (3rd of 5 numbers)', defaultPercentage: 0 }
        ];

        // Game descriptions in English and Hindi only
        const gameDescriptions = {
            firstFive: {
                en: 'Mark any 5 numbers on your ticket to win this game. Be quick - only the first player wins!',
                hi: 'इस गेम को जीतने के लिए अपने टिकट पर कोई भी 5 नंबर मार्क करें। जल्दी करें - केवल पहला खिलाड़ी जीतता है!'
            },
            lucky7: {
                en: 'Mark any 7 numbers on your ticket to win this game.',
                hi: 'इस गेम को जीतने के लिए अपने टिकट पर कोई भी 7 नंबर मार्क करें।'
            },
            topLine: {
                en: 'Complete all numbers in the first row to win. First player to complete wins!',
                hi: 'जीतने के लिए पहली पंक्ति के सभी नंबर पूरे करें। पहले पूरा करने वाला खिलाड़ी जीतता है!'
            },
            middleLine: {
                en: 'Complete all numbers in the middle row to win.',
                hi: 'जीतने के लिए बीच की पंक्ति के सभी नंबर पूरे करें।'
            },
            bottomLine: {
                en: 'Complete all numbers in the last row to win.',
                hi: 'जीतने के लिए आखिरी पंक्ति के सभी नंबर पूरे करें।'
            },
            corners: {
                en: 'Mark all 4 corner numbers of your ticket to win.',
                hi: 'जीतने के लिए अपने टिकट के सभी 4 कोने के नंबर मार्क करें।'
            },
            railwayTrack: {
                en: 'Complete both top and bottom rows (like railway tracks) to win.',
                hi: 'जीतने के लिए ऊपरी और निचली दोनों पंक्तियाँ (रेलवे ट्रैक की तरह) पूरी करें।'
            },
            pyramid: {
                en: 'Mark the pyramid pattern: middle number from top row (3rd of 5), middle 3 numbers from middle row (2nd, 3rd, 4th of 5), all 5 numbers from bottom row.',
                hi: 'पिरामिड पैटर्न मार्क करें: ऊपरी पंक्ति से बीच का नंबर (5 में से तीसरा), मध्य पंक्ति से बीच के 3 नंबर (5 में से दूसरा, तीसरा, चौथा), निचली पंक्ति के सभी 5 नंबर।'
            },
            breakfast: {
                en: 'Complete all numbers in the first 3 columns (columns 1, 2, 3).',
                hi: 'पहले 3 कॉलम (कॉलम 1, 2, 3) के सभी नंबर पूरे करें।'
            },
            lunch: {
                en: 'Complete all numbers in the middle 3 columns (columns 4, 5, 6).',
                hi: 'बीच के 3 कॉलम (कॉलम 4, 5, 6) के सभी नंबर पूरे करें।'
            },
            dinner: {
                en: 'Complete all numbers in the last 3 columns (columns 7, 8, 9).',
                hi: 'आखिरी 3 कॉलम (कॉलम 7, 8, 9) के सभी नंबर पूरे करें।'
            },
            fullHouse: {
                en: 'Mark all 15 numbers on your ticket to win the biggest prize! Only the first player to complete wins.',
                hi: 'सबसे बड़ा इनाम जीतने के लिए अपने टिकट के सभी 15 नंबर मार्क करें! केवल पहला खिलाड़ी जीतता है।'
            },
            house1: {
                en: 'Be the first player to complete all 15 numbers on your ticket.',
                hi: 'अपने टिकट के सभी 15 नंबर पूरे करने वाले पहले खिलाड़ी बनें।'
            },
            house2: {
                en: 'Be the second player to complete all 15 numbers on your ticket. Can only be won after House 1.',
                hi: 'अपने टिकट के सभी 15 नंबर पूरे करने वाले दूसरे खिलाड़ी बनें। केवल House 1 के बाद जीता जा सकता है।'
            },
            firstTwoLines: {
                en: 'Complete both first and second rows to win.',
                hi: 'जीतने के लिए पहली और दूसरी दोनों पंक्तियाँ पूरी करें।'
            },
            lastTwoLines: {
                en: 'Complete both second and third rows to win.',
                hi: 'जीतने के लिए दूसरी और तीसरी दोनों पंक्तियाँ पूरी करें।'
            },
            centerColumn: {
                en: 'Mark all numbers in the 5th column (middle column) to win.',
                hi: 'जीतने के लिए 5वें कॉलम (बीच का कॉलम) के सभी नंबर मार्क करें।'
            },
            bullsEye: {
                en: 'Mark the middle number from your middle row (3rd number out of the 5 numbers in the middle row).',
                hi: 'अपनी मध्य पंक्ति से बीच का नंबर मार्क करें (मध्य पंक्ति के 5 नंबरों में से तीसरा नंबर)।'
            }
        };

        function saveTicketCache(phone, markedNumbers) {
    const savedGame = localStorage.getItem('housieGame');
    if (!savedGame) return;
    
    const state = JSON.parse(savedGame);
    const cacheDuration = state.cacheDuration || 0;
    
    if (cacheDuration === 0) return;
    
    const cacheData = {
        marked: markedNumbers,
        timestamp: Date.now(),
        expiry: Date.now() + (cacheDuration * 60 * 1000),
        sessionId: window.currentSessionKey,
        isLocked: rageClickData[phone] ? rageClickData[phone].isLocked : false,
        warningLevel: rageClickWarnings[phone] || 0,
        rageClickData: rageClickData[phone] || { clicks: [], isLocked: false }
    };
    
    // Try multiple storage methods
    try {
        // 1. localStorage
        localStorage.setItem(`ticket_cache_${phone}`, JSON.stringify(cacheData));
    } catch (e) {
        console.log('localStorage failed:', e);
    }
    
    try {
        // 2. sessionStorage
        sessionStorage.setItem(`ticket_cache_${phone}`, JSON.stringify(cacheData));
    } catch (e) {
        console.log('sessionStorage failed:', e);
    }
    
    try {
        // 3. Cookie as fallback (works on all devices)
        const cookieData = btoa(JSON.stringify(cacheData));
        document.cookie = `ticket_${phone}=${cookieData}; max-age=${cacheDuration * 60}; path=/`;
    } catch (e) {
        console.log('Cookie failed:', e);
    }
}
function loadTicketCache(phone) {
    const cacheKey = `ticket_cache_${phone}`;
    let cached = null;
    
    // Try localStorage first
    try {
        cached = localStorage.getItem(cacheKey);
    } catch (e) {}
    
    // Try sessionStorage
    if (!cached) {
        try {
            cached = sessionStorage.getItem(cacheKey);
        } catch (e) {}
    }
    
    // Try cookie as fallback
    if (!cached) {
        try {
            const cookies = document.cookie.split(';');
            const ticketCookie = cookies.find(c => c.trim().startsWith(`ticket_${phone}=`));
            if (ticketCookie) {
                const cookieValue = ticketCookie.split('=')[1];
                cached = atob(cookieValue);
            }
        } catch (e) {}
    }
    
    if (!cached) return [];
    
    try {
        const cacheData = JSON.parse(cached);
        const now = Date.now();
        
        // Check if cache has expired
        if (now > cacheData.expiry) {
            // Clear all storage types
            try { localStorage.removeItem(cacheKey); } catch (e) {}
            try { sessionStorage.removeItem(cacheKey); } catch (e) {}
            try { document.cookie = `ticket_${phone}=; max-age=0; path=/`; } catch (e) {}
            return [];
        }
        
        // Don't check session ID - accept cache from any session
        // This ensures refresh always works
        
        // Restore lock state and warning level
        if (cacheData.rageClickData || cacheData.isLocked) {
            rageClickData[phone] = cacheData.rageClickData || { clicks: [], isLocked: cacheData.isLocked };
        }
        
        if (cacheData.warningLevel) {
            rageClickWarnings[phone] = cacheData.warningLevel;
        }
        
        return cacheData.marked || [];
    } catch (e) {
        console.error('Error parsing cache:', e);
        return [];
    }
}
        function clearExpiredCache() {
            const keys = Object.keys(localStorage);
            const now = Date.now();
            
            keys.forEach(key => {
                if (key.startsWith('ticket_cache_')) {
                    try {
                        const cached = JSON.parse(localStorage.getItem(key));
                        if (cached.expiry && now > cached.expiry) {
                            localStorage.removeItem(key);
                        }
                    } catch (e) {
                        // Invalid cache entry, remove it
                        localStorage.removeItem(key);
                    }
                }
            });
        }

        // Clear all player claims
        function clearAllPlayerClaims() {
            // Clear any existing player claims from sessionStorage
            const keys = Object.keys(sessionStorage);
            keys.forEach(key => {
                if (key.startsWith('player_claims_')) {
                    sessionStorage.removeItem(key);
                }
            });
        }

        // Toggle sequence mode
function toggleSequenceMode() {
    const mode = document.querySelector('input[name="sequenceMode"]:checked').value;
    const predeterminedInfo = document.getElementById('predeterminedInfo');
    const manualInfo = document.getElementById('manualInfo');
    const distributionSetup = document.querySelector('.distribution-setup');
    
    predeterminedInfo.style.display = 'none';
    manualInfo.style.display = 'none';
    
    if (mode === 'predetermined') {
        predeterminedInfo.style.display = 'block';
        // Show distribution options for predetermined mode
        if (distributionSetup) {
            distributionSetup.style.display = 'block';
        }
    } else if (mode === 'manual') {
        manualInfo.style.display = 'block';
        // Hide distribution options for manual mode
        if (distributionSetup) {
            distributionSetup.style.display = 'none';
        }
    } else {
        // Hide distribution options for random mode
        if (distributionSetup) {
            distributionSetup.style.display = 'none';
        }
    }
}

        // Show rage click warning
        function showRageClickWarning(phone, warningLevel, passKey = null) {
            // Create warning modal
            const warningDiv = document.createElement('div');
            warningDiv.className = 'rage-click-warning';
            
            let content = '';
            
            if (warningLevel === 1) {
                content = `
                    <h3>⚠️ Slow Down!</h3>
                    <p>Please wait for the admin to announce numbers before marking them. Clicking too fast may lead to your ticket being locked.</p>
                    <button onclick="closeRageWarning(this)">OK, I'll wait</button>
                `;
            } else if (warningLevel === 2) {
                content = `
                    <h3>🔒 Ticket Locked!</h3>
                    <p>Your ticket has been temporarily locked due to rapid clicking. Please enter the 4-digit pass key provided by the admin to unlock.</p>
                    <input type="text" id="passKeyInput" maxlength="4" placeholder="Enter pass key">
                    <button onclick="unlockTicket('${phone}', 1, this)">Unlock</button>
                `;
            } else if (warningLevel === 3) {
                content = `
                    <h3>🔒 Final Warning - Ticket Locked!</h3>
                    <p>This is your last chance. Your ticket has been locked again. Enter the pass key to unlock.</p>
                    <input type="text" id="passKeyInput" maxlength="4" placeholder="Enter pass key">
                    <button onclick="unlockTicket('${phone}', 2, this)">Unlock</button>
                `;
            } else {
                content = `
                    <h3>⛔ Maximum Warnings Reached</h3>
                    <p>You've been warned multiple times about clicking too fast. Please listen to the announcements and mark numbers accordingly.</p>
                    <button onclick="closeRageWarning(this)">I understand</button>
                `;
            }
            
            warningDiv.innerHTML = content;
            document.body.appendChild(warningDiv);
        }

        // Close rage warning
        function closeRageWarning(button) {
            const warning = button.closest('.rage-click-warning');
            if (warning) warning.remove();
        }

        // Unlock ticket
        function unlockTicket(phone, keyNumber, button) {
            const inputPassKey = button.closest('.ticket-locked-content, .rage-click-warning')?.querySelector('#passKeyInput')?.value;
            
            // Get pass keys from window object (passed via URL)
            const expectedKey = keyNumber === 1 ? window.passKey1 : window.passKey2;
            
            if (!expectedKey) {
                alert('Pass key not available. Please contact admin.');
                return;
            }
            
            if (inputPassKey === expectedKey) {
                // Unlock successful
                const warning = button.closest('.rage-click-warning');
                if (warning) warning.remove();
                
                // Remove locked overlay
                const lockedOverlay = document.querySelector('.ticket-locked-overlay');
                if (lockedOverlay) lockedOverlay.remove();
                
                // Reset lock state but keep warning count
                rageClickData[phone] = {
                    clicks: [],
                    isLocked: false
                };
                
                // Update cache with unlocked state
                saveTicketCache(phone, window.sessionMarked || []);
            } else {
                alert('Incorrect pass key! Please ask the admin for the correct key.');
            }
        }

        // Check for rage clicking
        function checkRageClick(phone) {
            // Check if rage click is enabled
            if (!window.rageClickEnabled) return false;
            
            const threshold = window.rageClickThreshold || 3;
            const now = Date.now();
            
            // Initialize tracking for this phone if not exists
            if (!rageClickData[phone]) {
                rageClickData[phone] = {
                    clicks: [],
                    isLocked: false
                };
            }
            
            if (!rageClickWarnings[phone]) {
                rageClickWarnings[phone] = 0;
            }
            
            // If already locked, prevent marking
            if (rageClickData[phone].isLocked) {
                return true;
            }
            
            // Add current click
            rageClickData[phone].clicks.push(now);
            
            // Remove clicks older than 1 second
            rageClickData[phone].clicks = rageClickData[phone].clicks.filter(t => now - t < 1000);
            
            // Check if threshold exceeded
            if (rageClickData[phone].clicks.length > threshold) {
                rageClickWarnings[phone]++;
                
                // Show appropriate warning
                if (rageClickWarnings[phone] === 1) {
                    showRageClickWarning(phone, 1);
                } else if (rageClickWarnings[phone] === 2) {
                    showRageClickWarning(phone, 2);
                    // Lock the ticket
                    rageClickData[phone].isLocked = true;
                    lockTicket();
                    // Save lock state to cache
                    saveTicketCache(phone, window.sessionMarked || []);
                    return true; // Prevent marking
                } else if (rageClickWarnings[phone] === 3) {
                    showRageClickWarning(phone, 3);
                    // Lock the ticket
                    rageClickData[phone].isLocked = true;
                    lockTicket();
                    // Save lock state to cache
                    saveTicketCache(phone, window.sessionMarked || []);
                    return true; // Prevent marking
                } else {
                    showRageClickWarning(phone, 4);
                }
                
                // Clear the clicks array
                rageClickData[phone].clicks = [];
            }
            
            return rageClickData[phone].isLocked;
        }

        // Lock ticket UI
        function lockTicket() {
            const ticketContainer = document.getElementById('ticketContainer');
            if (!ticketContainer) return;
            
            // Check if already locked
            if (ticketContainer.querySelector('.ticket-locked-overlay')) return;
            
            // Get current warning level
            const warningLevel = rageClickWarnings[window.currentPhone] || 2;
            const keyNumber = warningLevel >= 3 ? 2 : 1;
            
            const overlay = document.createElement('div');
            overlay.className = 'ticket-locked-overlay';
            overlay.innerHTML = `
                <div class="ticket-locked-content">
                    <h4>🔒 Ticket Locked</h4>
                    <p>Your ticket is locked due to rapid clicking.</p>
                    <p>Please get the unlock code from admin.</p>
                    <input type="text" id="passKeyInput" maxlength="4" placeholder="Enter pass key">
                    <button onclick="unlockTicket('${window.currentPhone}', ${keyNumber}, this)">Unlock</button>
                </div>
            `;
            
            ticketContainer.appendChild(overlay);
        }

        // Update rage click display
        function updateRageClickDisplay() {
            const enabled = document.getElementById('rageClickEnabled').checked;
            const passKeysDisplay = document.getElementById('passKeysDisplay');
            
            if (enabled && passKeysDisplay) {
                passKeysDisplay.style.display = 'block';
            } else if (passKeysDisplay) {
                passKeysDisplay.style.display = 'none';
            }
        }

        // Initialize
        function init() {
            // Check if pako library is loaded
            if (typeof pako === 'undefined') {
                console.error('Pako compression library not loaded. URLs will use fallback encoding.');
            }
            
            // Clear expired cache entries
            clearExpiredCache();
// Clear any stored pass keys from previous games
sessionStorage.removeItem('passKey1');
sessionStorage.removeItem('passKey2');
            
            // Check for stored team
            checkStoredTeam();
            
            // Clear any stored player claims when starting fresh
            clearAllPlayerClaims();
            
            
            // Update rage click display
            updateRageClickDisplay();
            
            // Populate game types
            const container = document.getElementById('gameTypesContainer');
            if (container) {
                container.innerHTML = '';
                
                allGameTypes.forEach(gameType => {
                    const div = document.createElement('div');
                    div.className = 'game-type-card';
                    // Remove pre-selection - start with all unchecked
                    div.id = `card_${gameType.id}`;
                    div.innerHTML = `
                        <div class="game-type-header">
                            <input type="checkbox" id="${gameType.id}" onchange="updateGameSelection('${gameType.id}')">
                            <label for="${gameType.id}">${gameType.name}</label>
                            <span class="info-icon" onclick="showGameInfo('${gameType.id}')">i</span>
                        </div>
                        <div class="game-type-inputs">
                            <div>
                                <label style="font-size: 12px; color: #666;">Percentage</label>
                                <input type="number" id="percentage_${gameType.id}" value="0" min="0" max="100" onchange="updatePercentage('${gameType.id}')">
                            </div>
                            <div>
                                <label style="font-size: 12px; color: #666;">Prize ₹</label>
                                <input type="number" id="prize_${gameType.id}" value="0" min="0" onchange="updatePrize('${gameType.id}')" readonly>
                            </div>
                        </div>
                    `;
                    container.appendChild(div);
                });
                
                // Initial distribution calculation and set readonly states
                updatePrizeDistribution();
                setTimeout(() => {
                    toggleDistributionMode();
                }, 100);
toggleSequenceMode();
                
                // Initialize selection colors after a brief delay
                setTimeout(() => {
                    allGameTypes.forEach(gameType => {
                        const checkbox = document.getElementById(gameType.id);
                        const card = document.getElementById(`card_${gameType.id}`);
                        if (checkbox && card) {
                            if (checkbox.checked) {
                                card.classList.add('selected');
                            } else {
                                card.classList.remove('selected');
                            }
                        }
                    });
                }, 100);
            }

            // Load voices
            loadVoices();

            // Check URL parameters for ticket data
            const urlParams = new URLSearchParams(window.location.search);
            const encodedData = urlParams.get('data');
            
            if (encodedData) {
                try {
                    // Decode ticket data using the new compression method
                    const ticketData = decodeTicketData(encodedData);
                    
                    if (!ticketData) {
                        throw new Error('Failed to decode ticket data');
                    }
// Check if ticket has expired
if (ticketData.expiryTime && ticketData.expiryTime > 0) {
    const now = Date.now();
    if (now > ticketData.expiryTime) {
        // Calculate how long ago it expired
        const expiredHours = Math.floor((now - ticketData.expiryTime) / (1000 * 60 * 60));
        const expiredDays = Math.floor(expiredHours / 24);
        
        let expiredText = '';
        if (expiredDays > 0) {
            expiredText = `${expiredDays} day${expiredDays > 1 ? 's' : ''} ago`;
        } else if (expiredHours > 0) {
            expiredText = `${expiredHours} hour${expiredHours > 1 ? 's' : ''} ago`;
        } else {
            expiredText = 'recently';
        }
        

  // Show expiry page
hideAll();
const container = document.querySelector('.container');
container.innerHTML = `
    <div class="header">
        <h1>🎱 Housie Game</h1>
    </div>
    <div class="card" style="text-align: center; max-width: 400px; margin: 2rem auto;">
        <div style="font-size: 4rem; margin-bottom: 1rem;">⏰</div>
        <h2 style="color: var(--danger); margin-bottom: 1rem;">Ticket Link Expired</h2>
        <div style="background: #fee2e2; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1.5rem;">
            <p style="margin: 0; color: #991b1b; font-weight: 500;">
                This ticket link expired ${expiredText}
            </p>
        </div>
        <p style="color: var(--text-secondary); margin-bottom: 1.5rem; line-height: 1.6;">
            Ticket links are only valid for a limited time after generation. 
            Please contact your game administrator to get a fresh ticket link.
        </p>
        <div style="background: #fef3c7; padding: 1rem; border-radius: 0.5rem; border: 1px solid #fbbf24;">
            <p style="margin: 0; color: #92400e; font-size: 0.875rem;">
                <strong>Note:</strong> Ask your admin to send you a new ticket link to join the game.
            </p>
        </div>
    </div>
`;
return; // Stop further processing
    }
}
                    
                    // Show player view directly
                    hideAll();
                    document.getElementById('playerView').classList.remove('hidden');
                    document.getElementById('playerName').textContent = ticketData.name;
                    
                    // Store player name for later use
                    window.playerName = ticketData.name;
                    
                    // Store selected games and prizes in session
                    window.selectedGames = ticketData.games || [];
                    window.gamePrizes = ticketData.prizes || {};
                    window.sequenceMode = ticketData.sequenceMode || 'random';
                    window.rageClickEnabled = ticketData.rageClickEnabled;
                    window.rageClickThreshold = ticketData.rageClickThreshold || 3;
                    window.passKey1 = ticketData.passKey1 || '';
                    window.passKey2 = ticketData.passKey2 || '';
window.notificationTheme = ticketData.notificationTheme || 'default';
window.celebrationEffect = ticketData.celebrationEffect || 'confetti';
window.playerPopupDuration = ticketData.playerPopupDuration || 5;
                    
                    // Store predetermined data if available
                    if (ticketData.predeterminedSequence) {
                        window.predeterminedSequence = ticketData.predeterminedSequence;
                        window.predeterminedWinners = ticketData.predeterminedWinners || {};
                    }
                    
                    // Display ticket
                    displayPlayerTicketDirect(ticketData.ticket, ticketData.phone);
                    
                    return;
                } catch (e) {
                    console.error('Error decoding ticket data:', e);
                }
            }

            // Check if winner summary is requested
            const winnersData = urlParams.get('winners');
            if (winnersData) {
                try {
                    const summaryData = decodeWinnersData(winnersData);
                    displayWinnersSummary(summaryData);
                    return;
                } catch (e) {
                    console.error('Error decoding winners data:', e);
                }
            }

            // Check if there's a game in progress (for admin)
            const savedGame = localStorage.getItem('housieGame');
            if (savedGame) {
                gameState = JSON.parse(savedGame);
                // Update pass keys display if available
                if (gameState.passKey1 && gameState.passKey2) {
                    if (document.getElementById('passKey1')) {
                        document.getElementById('passKey1').textContent = gameState.passKey1;
                    }
                    if (document.getElementById('passKey2')) {
                        document.getElementById('passKey2').textContent = gameState.passKey2;
                    }
                }
            }
            
            // Initialize number board
            initNumberBoard();
        }

        // Check for stored team
        function checkStoredTeam() {
            const storedTeam = localStorage.getItem('housieTeam');
            if (storedTeam) {
                const gameConfig = JSON.parse(storedTeam);
                const now = new Date().getTime();
                
                if (gameConfig.expiry && now < gameConfig.expiry) {
                    // Team data is still valid
                    const sameTeamBtn = document.getElementById('sameTeamBtn');
                    if (sameTeamBtn) {
                        sameTeamBtn.style.display = 'block';
                    }
                } else {
                    // Team data has expired
                    localStorage.removeItem('housieTeam');
                }
            }
        }

        // Start with same team
        function startWithSameTeam() {
            checkAdminPassword(() => {
                const storedTeam = localStorage.getItem('housieTeam');
                if (!storedTeam) return;
                
                const gameConfig = JSON.parse(storedTeam);
                
                // Pre-fill all game settings
                document.getElementById('playerCount').value = gameConfig.players.length;
                document.getElementById('kittyAmount').value = gameConfig.kittyAmount || 1000;
                document.getElementById('distributionMode').value = gameConfig.distributionMode || 'percentage';
                
                // Update mode immediately to set readonly states
                toggleDistributionMode();
                
                document.getElementById('glowDuration').value = gameConfig.glowDuration || 5;
                document.getElementById('adminPopupDuration').value = gameConfig.adminPopupDuration || 5;
                document.getElementById('playerPopupDuration').value = gameConfig.playerPopupDuration || 5;
                document.getElementById('confettiPlayer').checked = gameConfig.confettiPlayer !== false;
                document.getElementById('confettiAdmin').checked = gameConfig.confettiAdmin !== false;
                document.getElementById('cacheDuration').value = gameConfig.cacheDuration || 30;
                
                // Set rage click settings
                if (gameConfig.rageClickEnabled !== undefined) {
                    document.getElementById('rageClickEnabled').checked = gameConfig.rageClickEnabled;
                    document.getElementById('rageClickThreshold').value = gameConfig.rageClickThreshold || 3;
                }
// Generate fresh pass keys (don't use stored ones)
gameState.passKey1 = generatePassKey();
gameState.passKey2 = generatePassKey();

// Update display
if (document.getElementById('passKey1')) {
    document.getElementById('passKey1').textContent = gameState.passKey1;
}
if (document.getElementById('passKey2')) {
    document.getElementById('passKey2').textContent = gameState.passKey2;
}
                
                // Set sequence mode
                if (gameConfig.sequenceMode) {
                    document.querySelector(`input[name="sequenceMode"][value="${gameConfig.sequenceMode}"]`).checked = true;
                    toggleSequenceMode();
                }
                
                // Don't pre-check the store team checkbox when using stored data
                document.getElementById('storeTeam').checked = false;
                document.getElementById('storeHours').value = 0;
                
                // Store data for later use
                window.prefilledTeam = gameConfig.players;
                window.prefilledGameTypes = gameConfig.gameTypes;
                window.prefilledPrizes = gameConfig.prizes;
                window.prefilledDistributionMode = gameConfig.distributionMode;
                window.usingStoredTeam = true; // Flag to hide team storage section
                
                // Go to admin setup
                showAdminSetup(true); // Skip password check since already authenticated
                
                // Pre-select games and set prizes after DOM is ready
                setTimeout(() => {
                    if (gameConfig.gameTypes && gameConfig.prizes) {
                        // First uncheck all
                        allGameTypes.forEach(gameType => {
                            const checkbox = document.getElementById(gameType.id);
                            if (checkbox) {
                                checkbox.checked = false;
                                document.getElementById(`card_${gameType.id}`).classList.remove('selected');
                            }
                        });
                        
                        // Then check and set values for selected games
                        gameConfig.gameTypes.forEach(type => {
                            const checkbox = document.getElementById(type);
                            if (checkbox) {
                                checkbox.checked = true;
                                document.getElementById(`card_${type}`).classList.add('selected');
                                
                                // Set prize value
                                const prizeInput = document.getElementById(`prize_${type}`);
                                if (prizeInput && gameConfig.prizes[type]) {
                                    // Calculate percentage
                                    const percentage = Math.round((gameConfig.prizes[type] / gameConfig.kittyAmount) * 100);
                                    document.getElementById(`percentage_${type}`).value = percentage;
                                }
                            }
                        });
                        
                        // Handle fullHouse/house1/house2 logic
                        const fullHouseChecked = document.getElementById('fullHouse')?.checked;
                        const house1Checked = document.getElementById('house1')?.checked;
                        const house2Checked = document.getElementById('house2')?.checked;
                        
                        if (fullHouseChecked) {
                            ['house1', 'house2'].forEach(id => {
                                const checkbox = document.getElementById(id);
                                if (checkbox) checkbox.disabled = true;
                            });
                        } else if (house1Checked || house2Checked) {
                            const fullHouse = document.getElementById('fullHouse');
                            if (fullHouse) fullHouse.disabled = true;
                        }
                        
                        // Update prize distribution and set readonly states
                        updatePrizeDistribution();
                        toggleDistributionMode();
                        
                        // Set initial readonly states
                        setTimeout(() => {
                            toggleDistributionMode();
                        }, 200);
                    }
                }, 100);
            });
        }

        // Update game selection
        function updateGameSelection(gameId) {
            const checkbox = document.getElementById(gameId);
            const card = document.getElementById(`card_${gameId}`);
            
            // Update card styling
            if (checkbox.checked) {
                card.classList.add('selected');
                // Reset manual edit tracking for this game
                manuallyEditedPercentages.delete(gameId);
            } else {
                card.classList.remove('selected');
                // Reset values for unchecked games
                document.getElementById(`percentage_${gameId}`).value = 0;
                document.getElementById(`prize_${gameId}`).value = 0;
                // Remove from manually edited set
                manuallyEditedPercentages.delete(gameId);
            }
            
            // Handle Full House, House1, House2 logic
            if (gameId === 'fullHouse' && checkbox.checked) {
                // Disable house1 and house2
                ['house1', 'house2'].forEach(id => {
                    const houseCheckbox = document.getElementById(id);
                    if (houseCheckbox) {
                        houseCheckbox.checked = false;
                        houseCheckbox.disabled = true;
                        document.getElementById(`card_${id}`).classList.remove('selected');
                    }
                });
            } else if (gameId === 'fullHouse' && !checkbox.checked) {
                // Enable house1 and house2
                ['house1', 'house2'].forEach(id => {
                    const houseCheckbox = document.getElementById(id);
                    if (houseCheckbox) {
                        houseCheckbox.disabled = false;
                    }
                });
            }
            
            // Handle house1 or house2 selection
            if ((gameId === 'house1' || gameId === 'house2') && checkbox.checked) {
                // Disable fullHouse
                const fullHouseCheckbox = document.getElementById('fullHouse');
                if (fullHouseCheckbox) {
                    fullHouseCheckbox.checked = false;
                    fullHouseCheckbox.disabled = true;
                    document.getElementById('card_fullHouse').classList.remove('selected');
                }
            } else if ((gameId === 'house1' || gameId === 'house2')) {
                // Check if both house1 and house2 are unchecked
                const house1 = document.getElementById('house1');
                const house2 = document.getElementById('house2');
                if (house1 && house2 && !house1.checked && !house2.checked) {
                    // Enable fullHouse
                    const fullHouseCheckbox = document.getElementById('fullHouse');
                    if (fullHouseCheckbox) {
                        fullHouseCheckbox.disabled = false;
                    }
                }
            }
            
            // Auto-distribute percentages
            const mode = document.getElementById('distributionMode').value;
            if (mode === 'percentage') {
                autoDistributePercentages();
            } else {
                // In manual mode, recalculate kitty total
                updatePrize('dummy');
            }
        }

        // Update percentage for a specific game
        function updatePercentage(gameId) {
            const mode = document.getElementById('distributionMode').value;
            if (mode !== 'percentage') return;
            
            const percentageInput = document.getElementById(`percentage_${gameId}`);
            const newPercentage = parseFloat(percentageInput.value) || 0;
            
            // Mark this percentage as manually edited
            if (newPercentage > 0) {
                manuallyEditedPercentages.add(gameId);
            } else {
                manuallyEditedPercentages.delete(gameId);
            }
            
            // Limit to 100%
            if (newPercentage > 100) {
                percentageInput.value = 100;
                return updatePercentage(gameId);
            }
            
            // Get all selected games except the current one and manually edited ones
            const selectedGames = [];
            let totalManualPercentages = newPercentage;
            
            allGameTypes.forEach(gameType => {
                const checkbox = document.getElementById(gameType.id);
                if (checkbox && checkbox.checked) {
                    if (gameType.id !== gameId) {
                        if (manuallyEditedPercentages.has(gameType.id)) {
                            // This was manually edited, don't auto-adjust
                            const manualPercentage = parseFloat(document.getElementById(`percentage_${gameType.id}`).value) || 0;
                            totalManualPercentages += manualPercentage;
                        } else {
                            // This can be auto-adjusted
                            selectedGames.push(gameType.id);
                        }
                    }
                }
            });
            
            // Calculate remaining percentage to distribute
            const remainingPercentage = 100 - totalManualPercentages;
            
            if (selectedGames.length > 0 && remainingPercentage >= 0) {
                // Distribute equally among non-manually-edited games
                const equalShare = Math.floor(remainingPercentage / selectedGames.length);
                const remainder = remainingPercentage - (equalShare * selectedGames.length);
                
                selectedGames.forEach((id, index) => {
                    const extra = index < remainder ? 1 : 0;
                    document.getElementById(`percentage_${id}`).value = equalShare + extra;
                });
            } else if (remainingPercentage < 0) {
                // Total exceeds 100%, reset current to maximum allowed
                const maxAllowed = 100 - (totalManualPercentages - newPercentage);
                percentageInput.value = Math.max(0, maxAllowed);
                manuallyEditedPercentages.delete(gameId); // Remove from manual set since we're adjusting it
            }
            
            updatePrizeDistribution();
        }

        // Update prize for a specific game
        function updatePrize(gameId) {
            const mode = document.getElementById('distributionMode').value;
            if (mode !== 'manual') return;
            
            // Calculate total from all prize inputs
            let totalAmount = 0;
            allGameTypes.forEach(gameType => {
                const checkbox = document.getElementById(gameType.id);
                const prizeInput = document.getElementById(`prize_${gameType.id}`);
                if (checkbox && checkbox.checked && prizeInput) {
                    const prize = parseFloat(prizeInput.value) || 0;
                    totalAmount += prize;
                }
            });
            
            // Update kitty amount display
            document.getElementById('kittyAmount').value = totalAmount;
            
            updatePrizeDistribution();
        }

        // Auto-distribute percentages
        function autoDistributePercentages() {
            const mode = document.getElementById('distributionMode').value;
            if (mode !== 'percentage') return;
            
            // Clear manually edited percentages when auto-distributing
            manuallyEditedPercentages.clear();
            
            // Count selected games
            let selectedCount = 0;
            allGameTypes.forEach(gameType => {
                const checkbox = document.getElementById(gameType.id);
                if (checkbox && checkbox.checked) {
                    selectedCount++;
                }
            });
            
            if (selectedCount === 0) {
                updatePrizeDistribution();
                return;
            }
            
            // Calculate equal percentage
            const equalPercentage = Math.floor(100 / selectedCount);
            const remainder = 100 - (equalPercentage * selectedCount);
            
            // Distribute percentages
            let remainderAssigned = 0;
            allGameTypes.forEach(gameType => {
                const checkbox = document.getElementById(gameType.id);
                const percentageInput = document.getElementById(`percentage_${gameType.id}`);
                
                if (checkbox && checkbox.checked && percentageInput) {
                    // Add 1 to some games to distribute remainder
                    const extra = remainderAssigned < remainder ? 1 : 0;
                    percentageInput.value = equalPercentage + extra;
                    remainderAssigned += extra;
                } else if (percentageInput) {
                    percentageInput.value = 0;
                }
            });
            
            updatePrizeDistribution();
        }

        // Show game info popup
        function showGameInfo(gameId) {
            const desc = gameDescriptions[gameId];
            if (!desc) return;
            
            const backdrop = document.createElement('div');
            backdrop.className = 'popup-backdrop';
            
            const popup = document.createElement('div');
            popup.className = 'game-info-popup';
            popup.innerHTML = `
                <button class="close-btn" onclick="closeGameInfo()">×</button>
                <h3>${getGameTypeName(gameId)}</h3>
                <p><strong>English:</strong><br>${desc.en}</p>
                <p><strong>हिंदी:</strong><br>${desc.hi}</p>
                <p style="margin-top: 1rem; font-size: 0.8125rem; color: #6b7280; font-style: italic;">
                    Note: If multiple players complete the same pattern on the same number call, they will split the prize equally. Otherwise, only the first player to complete the pattern wins.
                </p>
            `;
            
            backdrop.onclick = closeGameInfo;
            
            document.body.appendChild(backdrop);
            document.body.appendChild(popup);
        }
// Show distribution info popup
function showDistributionInfo() {
    const backdrop = document.createElement('div');
    backdrop.className = 'popup-backdrop';
    
    const popup = document.createElement('div');
    popup.className = 'game-info-popup';
    popup.innerHTML = `
        <button class="close-btn" onclick="closeDistributionInfo()">×</button>
        <h3>Winner Distribution Modes</h3>
        <p><strong>Completely Random:</strong><br>
        The traditional way - winners are determined naturally based on luck and number calls. Some players might win multiple games while others might not win any.</p>
        
        <p><strong>Majority Winners:</strong><br>
        The system ensures that 60-70% of players win at least one game. The remaining games are distributed randomly. Good balance between fairness and excitement.</p>
        
        <p><strong>Everyone Wins:</strong><br>
        Every player is guaranteed to win at least one game. After ensuring everyone has won once, remaining games are distributed randomly. Perfect for family gatherings where you want everyone to feel included.</p>
        
        <p style="margin-top: 1rem; font-size: 0.8125rem; color: #6b7280; font-style: italic;">
            Note: This setting works across all game modes (Random, Predetermined, and Manual Claims).
        </p>
    `;
    
    backdrop.onclick = closeDistributionInfo;
    
    document.body.appendChild(backdrop);
    document.body.appendChild(popup);
}

// Close distribution info popup
function closeDistributionInfo() {
    const backdrop = document.querySelector('.popup-backdrop');
    const popup = document.querySelector('.game-info-popup');
    if (backdrop) backdrop.remove();
    if (popup) popup.remove();
}
        
        // Close game info popup
        function closeGameInfo() {
            const backdrop = document.querySelector('.popup-backdrop');
            const popup = document.querySelector('.game-info-popup');
            if (backdrop) backdrop.remove();
            if (popup) popup.remove();
        }
        
        // Show confetti animation - fixed for better compatibility
        function showConfetti() {
            const container = document.createElement('div');
            container.className = 'confetti-container';
            
            const colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'];
            
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animationDelay = Math.random() * 3 + 's';
                confetti.style.animationDuration = (Math.random() * 3 + 3) + 's';
                confetti.style.animation = `confetti-fall ${(Math.random() * 3 + 3)}s linear ${Math.random() * 3}s`;
                container.appendChild(confetti);
            }
            
            document.body.appendChild(container);
            
            setTimeout(() => {
                if (container && container.parentNode) {
                    container.parentNode.removeChild(container);
                }
            }, 6000);
        }

// Show fireworks animation
function showFireworks() {
    const container = document.createElement('div');
    container.className = 'fireworks-container';
    
    // Launch 8 fireworks for more impact
    for (let i = 0; i < 8; i++) {
        setTimeout(() => {
            const colors = ['#ff006e', '#8338ec', '#3a86ff', '#06ffa5', '#ffbe0b', '#ff5722', '#00ff41', '#ff1744', '#00e5ff', '#ffea00'];
            const color = colors[Math.floor(Math.random() * colors.length)];
            const launchX = Math.random() * window.innerWidth;
            
            // Create launch trail
            const firework = document.createElement('div');
            firework.className = 'firework';
            firework.style.left = launchX + 'px';
            firework.style.width = '6px';
            firework.style.height = '6px';
            firework.style.background = color;
            firework.style.boxShadow = `0 0 10px ${color}, 0 0 20px ${color}, 0 0 30px ${color}`;
            firework.style.animation = 'firework-launch 1.2s ease-out forwards';
            
            container.appendChild(firework);
            
            // Create burst after launch
            setTimeout(() => {
                const burstX = launchX;
                const burstY = window.innerHeight * 0.3; // Higher burst
                
                // Create 50 particles for bigger burst
                for (let j = 0; j < 50; j++) {
                    const particle = document.createElement('div');
                    particle.className = 'firework-burst';
                    particle.style.left = burstX + 'px';
                    particle.style.top = burstY + 'px';
                    particle.style.width = '8px';
                    particle.style.height = '8px';
                    particle.style.background = color;
                    particle.style.boxShadow = `0 0 15px ${color}, 0 0 30px ${color}`;
                    
                    const angle = (j / 50) * 360;
                    const velocity = 100 + Math.random() * 200; // Increased velocity
                    const radian = angle * Math.PI / 180;
                    const vx = Math.cos(radian) * velocity;
                    const vy = Math.sin(radian) * velocity;
                    
                    particle.style.setProperty('--vx', vx + 'px');
                    particle.style.setProperty('--vy', vy + 'px');
                    particle.style.animation = 'firework-burst 2s ease-out forwards';
                    
                    container.appendChild(particle);
                }
                
                firework.remove();
            }, 1200);
        }, i * 300); // Reduced delay for more overlap
    }
    
    document.body.appendChild(container);
    
    setTimeout(() => {
        if (container && container.parentNode) {
            container.remove();
        }
    }, 5000);
}

// Show starburst animation
function showStarburst() {
    const container = document.createElement('div');
    container.className = 'starburst-container';
    
    // Create 5 starbursts for more impact
    for (let burst = 0; burst < 5; burst++) {
        setTimeout(() => {
            const centerX = window.innerWidth / 2 + (Math.random() - 0.5) * 400;
            const centerY = window.innerHeight / 2 + (Math.random() - 0.5) * 300;
            const colors = ['#FFD700', '#FFA500', '#FF69B4', '#00CED1', '#9370DB', '#32CD32', '#FF1493', '#00FA9A'];
            
            // Create 40 stars per burst
            for (let i = 0; i < 40; i++) {
                const star = document.createElement('div');
                star.className = 'star-particle';
                star.style.left = centerX + 'px';
                star.style.top = centerY + 'px';
                star.style.width = '12px';
                star.style.height = '12px';
                
                const color = colors[Math.floor(Math.random() * colors.length)];
                star.style.background = color;
                star.style.boxShadow = `0 0 20px ${color}, 0 0 40px ${color}, 0 0 60px ${color}`;
                
                const angle = (i / 40) * 360 + Math.random() * 20;
                const velocity = 150 + Math.random() * 250;
                const radian = angle * Math.PI / 180;
                const vx = Math.cos(radian) * velocity;
                const vy = Math.sin(radian) * velocity;
                
                star.style.setProperty('--vx', vx + 'px');
                star.style.setProperty('--vy', vy + 'px');
                star.style.animation = 'star-shoot 2s ease-out forwards';
                star.style.animationDelay = Math.random() * 0.3 + 's';
                
                container.appendChild(star);
            }
        }, burst * 400);
    }
    
    document.body.appendChild(container);
    
    setTimeout(() => {
        if (container && container.parentNode) {
            container.remove();
        }
    }, 4000);
}
// Show celebration based on settings
function showCelebration() {
    let effect = 'confetti'; // Default
    
    // Check if we're in player mode first (using URL data)
    // Make sure it's a string, not an HTML element!
    if (window.celebrationEffect && typeof window.celebrationEffect === 'string') {
        effect = window.celebrationEffect;
    } else {
        // Admin mode - check localStorage
        const savedGame = localStorage.getItem('housieGame');
        if (savedGame) {
            const state = JSON.parse(savedGame);
            
            // Check if we're on admin or player view
            const isAdmin = document.getElementById('adminDashboard') && !document.getElementById('adminDashboard').classList.contains('hidden');
            
            // Check if celebrations are enabled
            if (isAdmin && !state.confettiAdmin) return;
            if (!isAdmin && !state.confettiPlayer) return;
            
            effect = state.celebrationEffect || 'confetti';
        }
    }
    
    // Show the selected effect
    switch (effect) {
        case 'fireworks':
            showFireworks();
            break;
        case 'starburst':
            showStarburst();
            break;
        default:
            showConfetti();
    }
}
function getNotificationThemeClass() {
    let theme = 'default';
    
    // Check if we're in admin mode (adminDashboard is visible)
    const isAdmin = document.getElementById('adminDashboard') && !document.getElementById('adminDashboard').classList.contains('hidden');
    
    if (isAdmin) {
        // Admin mode - check localStorage
        const savedGame = localStorage.getItem('housieGame');
        if (savedGame) {
            const state = JSON.parse(savedGame);
            theme = state.notificationTheme || 'default';
        }
    } else if (window.notificationTheme) {
        // Player mode - use URL data
        theme = window.notificationTheme;
    }
    
    switch (theme) {
        case 'neon': return 'neon-theme';
        case 'royal': return 'royal-theme';
        case 'aurora': return 'aurora-theme';
        case 'matrix': return 'matrix-theme';
        default: return '';
    }
}


        // Load available voices
        function loadVoices() {
            if ('speechSynthesis' in window) {
                const voiceSelect = document.getElementById('voiceSelect');
                
                function populateVoices() {
                    const voices = speechSynthesis.getVoices();
                    voiceSelect.innerHTML = '';
                    
                    // Group voices by language - only English and Hindi
                    const englishVoices = voices.filter(voice => voice.lang.startsWith('en'));
                    const hindiVoices = voices.filter(voice => voice.lang.startsWith('hi'));
                    
                    // Try to find good quality voices
                    const femaleVoices = englishVoices.filter(v => 
                        v.name.toLowerCase().includes('female') || 
                        v.name.toLowerCase().includes('woman') ||
                        v.name.toLowerCase().includes('samantha') ||
                        v.name.toLowerCase().includes('victoria') ||
                        v.name.toLowerCase().includes('karen') ||
                        v.name.toLowerCase().includes('moira')
                    );
                    
                    const maleVoices = englishVoices.filter(v => 
                        v.name.toLowerCase().includes('male') || 
                        v.name.toLowerCase().includes('man') ||
                        v.name.toLowerCase().includes('daniel') ||
                        v.name.toLowerCase().includes('alex') ||
                        v.name.toLowerCase().includes('rishi')
                    );
                    
                    // Add voices to select
                    if (femaleVoices.length > 0) {
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = 'Female Voices';
                        femaleVoices.forEach((voice, i) => {
                            const option = document.createElement('option');
                            option.value = voice.name;
                            option.textContent = voice.name;
                            if (i === 0) option.selected = true;
                            optgroup.appendChild(option);
                        });
                        voiceSelect.appendChild(optgroup);
                    }
                    
                    if (maleVoices.length > 0) {
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = 'Male Voices';
                        maleVoices.forEach(voice => {
                            const option = document.createElement('option');
                            option.value = voice.name;
                            option.textContent = voice.name;
                            optgroup.appendChild(option);
                        });
                        voiceSelect.appendChild(optgroup);
                    }
                    
                    // Add Hindi voices if available
                    if (hindiVoices.length > 0) {
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = 'Hindi Voices';
                        hindiVoices.forEach(voice => {
                            const option = document.createElement('option');
                            option.value = voice.name;
                            option.textContent = voice.name;
                            optgroup.appendChild(option);
                        });
                        voiceSelect.appendChild(optgroup);
                    }
                    
                    // Add remaining English voices
                    const otherVoices = englishVoices.filter(v => 
                        !femaleVoices.includes(v) && !maleVoices.includes(v)
                    );
                    
                    if (otherVoices.length > 0) {
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = 'Other Voices';
                        otherVoices.forEach(voice => {
                            const option = document.createElement('option');
                            option.value = voice.name;
                            option.textContent = voice.name;
                            optgroup.appendChild(option);
                        });
                        voiceSelect.appendChild(optgroup);
                    }
                }
                
                // Populate voices when they're loaded
                if (speechSynthesis.getVoices().length > 0) {
                    populateVoices();
                } else {
                    speechSynthesis.onvoiceschanged = populateVoices;
                }
            }
        }

        // Update voice settings
        function updateVoiceSettings() {
            // This will be used when speaking numbers
        }

        // Toggle distribution mode
        function toggleDistributionMode() {
            const mode = document.getElementById('distributionMode').value;
            const kittyInput = document.getElementById('kittyAmount');
            const kittyLabel = document.getElementById('kittyLabel');
            
            allGameTypes.forEach(gameType => {
                const percentageInput = document.getElementById(`percentage_${gameType.id}`);
                const prizeInput = document.getElementById(`prize_${gameType.id}`);
                
                if (mode === 'percentage') {
                    percentageInput.readOnly = false;
                    prizeInput.readOnly = true;
                    kittyInput.readOnly = false;
                    kittyLabel.textContent = 'Total Kitty Amount (₹):';
                } else {
                    percentageInput.readOnly = true;
                    prizeInput.readOnly = false;
                    kittyInput.readOnly = true;
                    kittyLabel.textContent = 'Total (Sum of Prizes) ₹:';
                }
            });
            
            if (mode === 'percentage') {
                autoDistributePercentages();
            } else {
                // In manual mode, update kitty from sum of prizes
                updatePrize('dummy');
            }
        }

        // Update prize distribution
        function updatePrizeDistribution() {
            const kittyAmount = parseFloat(document.getElementById('kittyAmount').value) || 0;
            const mode = document.getElementById('distributionMode').value;
            
            let totalDistributed = 0;
            
            if (mode === 'percentage') {
                // Calculate prize amounts based on percentages
                allGameTypes.forEach(gameType => {
                    const checkbox = document.getElementById(gameType.id);
                    const prizeInput = document.getElementById(`prize_${gameType.id}`);
                    const percentageInput = document.getElementById(`percentage_${gameType.id}`);
                    
                    if (checkbox && checkbox.checked) {
                        const percentage = parseFloat(percentageInput.value) || 0;
                        const prize = Math.round((kittyAmount * percentage) / 100);
                        prizeInput.value = prize;
                        totalDistributed += prize;
                    } else {
                        prizeInput.value = 0;
                        percentageInput.value = 0;
                    }
                });
            } else {
                // Manual mode - calculate total from prize inputs and update percentages
                allGameTypes.forEach(gameType => {
                    const checkbox = document.getElementById(gameType.id);
                    const prizeInput = document.getElementById(`prize_${gameType.id}`);
                    const percentageInput = document.getElementById(`percentage_${gameType.id}`);
                    
                    if (checkbox && checkbox.checked) {
                        const prize = parseFloat(prizeInput.value) || 0;
                        totalDistributed += prize;
                        
                        // Update percentage display
                        if (kittyAmount > 0) {
                            const percentage = Math.round((prize / kittyAmount) * 100);
                            percentageInput.value = percentage;
                        }
                    } else {
                        prizeInput.value = 0;
                        percentageInput.value = 0;
                    }
                });
            }
            
            // Update total distributed display
            const totalElement = document.getElementById('totalDistributed');
            totalElement.textContent = `Total Distributed: ₹${totalDistributed}`;
            
            if (mode === 'percentage') {
                if (totalDistributed > kittyAmount) {
                    totalElement.style.color = '#ef4444';
                } else {
                    totalElement.style.color = '#10b981';
                }
            } else {
                // In manual mode, always show green as kitty adjusts to match
                totalElement.style.color = '#10b981';
            }
        }

        // Password protection
        const ADMIN_PASSWORD = 'My_first_game_4@';
        
        function checkAdminPassword(callback) {
            const password = prompt('Enter admin password:');
            if (password === ADMIN_PASSWORD) {
                callback();
            } else if (password !== null) {
                alert('Incorrect password!');
            }
        }

        // Navigation functions
        function showLanding() {
            hideAll();
            document.getElementById('landingPage').classList.remove('hidden');
            // Reset the stored team flag
            window.usingStoredTeam = false;
        }

        function showAdminSetup(skipPasswordCheck = false) {
            const proceed = () => {
                hideAll();
                document.getElementById('adminSetup').classList.remove('hidden');
                    // Generate fresh pass keys for new game setup
    gameState.passKey1 = generatePassKey();
    gameState.passKey2 = generatePassKey();
    
    // Update pass keys display
    if (document.getElementById('passKey1')) {
        document.getElementById('passKey1').textContent = gameState.passKey1;
    }
    if (document.getElementById('passKey2')) {
        document.getElementById('passKey2').textContent = gameState.passKey2;
    }
                // Update rage click display
                updateRageClickDisplay();
                
                // Hide team storage section if using stored team
                const teamStorageSection = document.querySelector('.team-storage-section');
                if (teamStorageSection) {
                    if (window.usingStoredTeam) {
                        teamStorageSection.style.display = 'none';
                    } else {
                        teamStorageSection.style.display = 'block';
                    }
                }
            };
            
            if (skipPasswordCheck) {
                proceed();
            } else {
                checkAdminPassword(proceed);
            }
        }

        function showJoinGame() {
            hideAll();
            document.getElementById('joinGame').classList.remove('hidden');
        }

        function hideAll() {
            document.querySelectorAll('#landingPage, #adminSetup, #playerRegistration, #adminDashboard, #playerView, #joinGame').forEach(el => {
                el.classList.add('hidden');
            });
        }

        // Resume admin game
        function resumeAdmin() {
            checkAdminPassword(() => {
                const savedGame = localStorage.getItem('housieGame');
                if (!savedGame) {
                    alert('No game in progress!');
                    return;
                }
                
                gameState = JSON.parse(savedGame);
                
                // Migrate old winners format to new format
                if (gameState.winners) {
                    Object.keys(gameState.winners).forEach(type => {
                        if (Array.isArray(gameState.winners[type])) {
                            // Old format - convert to new
                            gameState.winners[type] = {
                                list: gameState.winners[type],
                                winningNumbers: {}
                            };
                            // Mark all as manual claims since we don't know the winning numbers
                            if (gameState.winners[type].list.length > 0) {
                                gameState.winners[type].winningNumbers['manual'] = gameState.winners[type].list;
                            }
                        }
                    });
                    // Save the migrated format
                    saveGameState();
                }
                
                hideAll();
                document.getElementById('adminDashboard').classList.remove('hidden');
                
                // Show predetermined winners if available
                if (gameState.sequenceMode === 'predetermined' && gameState.predeterminedWinners) {
                    displayPredeterminedWinners();
                }
                
                // Update pass keys display if available
                if (gameState.passKey1 && gameState.passKey2) {
                    const passKeysDisplay = document.getElementById('passKeysDisplay');
                    if (passKeysDisplay) {
                        document.getElementById('passKey1Dashboard').textContent = gameState.passKey1;
                        document.getElementById('passKey2Dashboard').textContent = gameState.passKey2;
                        passKeysDisplay.style.display = gameState.rageClickEnabled ? 'block' : 'none';
                    }
                }
                
                // Restore board state
                initNumberBoard();
                updateAdminDisplay();
            });
        }

        // Update admin display
        function updateAdminDisplay() {
            // Update called numbers on board
            gameState.calledNumbers.forEach(num => {
                const cell = document.getElementById(`num-${num}`);
                if (cell) cell.classList.add('called');
            });
            
            // Update counts and current number
            document.getElementById('calledCount').textContent = gameState.calledNumbers.length;
            
if (gameState.calledNumbers.length > 0) {
    const lastNumber = gameState.calledNumbers[gameState.calledNumbers.length - 1];
    document.getElementById('currentNumber').textContent = lastNumber;
    
    const lastTwenty = gameState.calledNumbers.slice(-20).reverse();
    document.getElementById('lastNumbers').textContent = 
        lastTwenty.length > 1 ? `Last numbers: ${lastTwenty.join(', ')}` : '';
}
            
            // Update rage click pass keys display
            if (gameState.rageClickEnabled) {
                document.getElementById('passKey1Dashboard').textContent = gameState.passKey1;
                document.getElementById('passKey2Dashboard').textContent = gameState.passKey2;
                document.getElementById('rageClickPassKeys').style.display = 'block';
            } else {
                document.getElementById('rageClickPassKeys').style.display = 'none';
            }
        }

        // Setup players
// Setup players
function setupPlayers() {
    // Generate new pass keys for this game
    gameState.passKey1 = generatePassKey();
    gameState.passKey2 = generatePassKey();
    
    // Update pass keys display
    if (document.getElementById('passKey1')) {
        document.getElementById('passKey1').textContent = gameState.passKey1;
    }
    if (document.getElementById('passKey2')) {
        document.getElementById('passKey2').textContent = gameState.passKey2;
    }
    
    const count = parseInt(document.getElementById('playerCount').value);
    if (count < 1 || count > 50) {
        alert('Please enter a valid number of players (1-50)');
        return;
    }
    
    const playerInputsDiv = document.getElementById('playerInputs');
    playerInputsDiv.innerHTML = '';
    
    // Check for prefilled team data
    const hasPrefilledData = window.prefilledTeam && window.prefilledTeam.length === count;
    
    // Create a container for better scrolling with many players
    const container = document.createElement('div');
    container.style.maxHeight = '400px';
    container.style.overflowY = 'auto';
    
    for (let i = 1; i <= count; i++) {
        const playerCard = document.createElement('div');
        playerCard.className = 'player-input-card';
        
        let defaultName = '';
        let defaultPhone = '';
        
        if (hasPrefilledData && window.prefilledTeam[i-1]) {
            defaultName = window.prefilledTeam[i-1].name || '';
            defaultPhone = window.prefilledTeam[i-1].phone || '';
        }
        
        playerCard.innerHTML = `
    <h4>Player ${i}</h4>
    <input type="text" id="playerName${i}" placeholder="Name" required value="${defaultName}">
    <input type="tel" id="playerPhone${i}" placeholder="Phone Number" required value="${defaultPhone}" pattern="[0-9]+" title="Please enter numbers only">
`;
        container.appendChild(playerCard);
    }
    
    playerInputsDiv.appendChild(container);
    
    hideAll();
    document.getElementById('playerRegistration').classList.remove('hidden');
}

        // Generate ticket
        function generateTicket() {
            const ticket = Array(3).fill(null).map(() => Array(9).fill(0));
            
            // Each row must have exactly 5 numbers
            // Each column must have at least one number
            // Total 15 numbers on the ticket
            
            // First, ensure each column has at least one number
            const columnNumbers = Array(9).fill(null).map(() => []);
            
            // Generate 1-3 numbers for each column
            for (let col = 0; col < 9; col++) {
                const min = col * 10 + 1;
                const max = col === 8 ? 90 : (col + 1) * 10;
                
                // Determine how many numbers for this column (1-3)
                const count = Math.floor(Math.random() * 3) + 1;
                
                const usedInColumn = new Set();
                for (let i = 0; i < count; i++) {
                    let num;
                    do {
                        num = Math.floor(Math.random() * (max - min + 1)) + min;
                    } while (usedInColumn.has(num));
                    usedInColumn.add(num);
                    columnNumbers[col].push(num);
                }
            }
            
            // Sort each column's numbers in ascending order
            columnNumbers.forEach(col => col.sort((a, b) => a - b));
            
            // Now we need to select exactly 15 numbers total
            let totalNumbers = columnNumbers.reduce((sum, col) => sum + col.length, 0);
            
            // Adjust to have exactly 15 numbers
            while (totalNumbers > 15) {
                // Remove numbers from columns that have more than 1
                for (let col = 0; col < 9 && totalNumbers > 15; col++) {
                    if (columnNumbers[col].length > 1) {
                        columnNumbers[col].pop();
                        totalNumbers--;
                    }
                }
            }
            
            while (totalNumbers < 15) {
                // Add numbers to columns that have less than 3
                for (let col = 0; col < 9 && totalNumbers < 15; col++) {
                    if (columnNumbers[col].length < 3) {
                        const min = col * 10 + 1;
                        const max = col === 8 ? 90 : (col + 1) * 10;
                        let num;
                        do {
                            num = Math.floor(Math.random() * (max - min + 1)) + min;
                        } while (columnNumbers[col].includes(num));
                        columnNumbers[col].push(num);
                        columnNumbers[col].sort((a, b) => a - b);
                        totalNumbers++;
                    }
                }
            }
            
            // Now distribute the numbers to rows
            // Each row must have exactly 5 numbers
            const rowCounts = [0, 0, 0];
            
            // For each column, place numbers in rows
            columnNumbers.forEach((nums, col) => {
                if (nums.length === 1) {
                    // Single number - randomly choose a row that has space
                    const availableRows = [];
                    for (let r = 0; r < 3; r++) {
                        if (rowCounts[r] < 5) availableRows.push(r);
                    }
                    if (availableRows.length > 0) {
                        // Randomly select from available rows
                        const selectedRow = availableRows[Math.floor(Math.random() * availableRows.length)];
                        ticket[selectedRow][col] = nums[0];
                        rowCounts[selectedRow]++;
                    }
                } else if (nums.length === 2) {
                    // Two numbers - place in different rows
                    const availableRows = [];
                    for (let r = 0; r < 3; r++) {
                        if (rowCounts[r] < 5) availableRows.push(r);
                    }
                    
                    if (availableRows.length >= 2) {
                        // Randomly select 2 rows from available rows
                        const shuffled = availableRows.sort(() => Math.random() - 0.5);
                        const rows = shuffled.slice(0, 2).sort((a, b) => a - b);
                        ticket[rows[0]][col] = nums[0];
                        ticket[rows[1]][col] = nums[1];
                        rowCounts[rows[0]]++;
                        rowCounts[rows[1]]++;
                    }
                } else if (nums.length === 3) {
                    // Three numbers - one in each row (sorted top to bottom)
                    ticket[0][col] = nums[0];
                    ticket[1][col] = nums[1];
                    ticket[2][col] = nums[2];
                    rowCounts[0]++;
                    rowCounts[1]++;
                    rowCounts[2]++;
                }
            });
            
            // Fix any row that doesn't have exactly 5 numbers
            for (let row = 0; row < 3; row++) {
                while (rowCounts[row] < 5) {
                    // Find columns where we can add a number
                    const availableCols = [];
                    for (let col = 0; col < 9; col++) {
                        if (ticket[row][col] === 0) {
                            // Check if this column has unused numbers
                            const usedInCol = [ticket[0][col], ticket[1][col], ticket[2][col]].filter(n => n > 0);
                            const availableInCol = columnNumbers[col].filter(n => !usedInCol.includes(n));
                            if (availableInCol.length > 0) {
                                availableCols.push({col, numbers: availableInCol});
                            }
                        }
                    }
                    
                    if (availableCols.length > 0) {
                        // Randomly select a column
                        const selected = availableCols[Math.floor(Math.random() * availableCols.length)];
                        ticket[row][selected.col] = selected.numbers[0];
                        rowCounts[row]++;
                    } else {
                        // Fallback - generate a new number in an empty cell
                        for (let col = 0; col < 9; col++) {
                            if (ticket[row][col] === 0) {
                                const min = col * 10 + 1;
                                const max = col === 8 ? 90 : (col + 1) * 10;
                                let num;
                                do {
                                    num = Math.floor(Math.random() * (max - min + 1)) + min;
                                } while (ticket.flat().includes(num));
                                ticket[row][col] = num;
                                rowCounts[row]++;
                                if (rowCounts[row] >= 5) break;
                            }
                        }
                    }
                }
                
                // Remove extra numbers if any row has more than 5
                while (rowCounts[row] > 5) {
                    for (let col = 8; col >= 0; col--) {
                        if (ticket[row][col] > 0) {
                            // Check if removing this number leaves the column empty
                            const colHasOtherNumbers = ticket[0][col] + ticket[1][col] + ticket[2][col] - ticket[row][col] > 0;
                            if (colHasOtherNumbers) {
                                ticket[row][col] = 0;
                                rowCounts[row]--;
                                break;
                            }
                        }
                    }
                }
            }
            
            return ticket;
        }

// Determine winners for predetermined sequence
function determinePredeterminedWinners() {
    const distributionMode = gameState.winnerDistribution || 'random';
    const totalPlayers = gameState.players.length;
    const totalGames = gameState.gameTypes.length;
    
    console.log(`Distribution Mode: ${distributionMode}, Players: ${totalPlayers}, Games: ${totalGames}`);
    
    // Generate sequences until we find one that meets our distribution goal
    let sequence = [];
    let attempts = 0;
const maxAttempts = distributionMode === 'everyone' ? 1000 : 200; // More attempts for everyone wins mode
    let bestWinners = null;
    let bestStats = { uniqueWinners: 0, distribution: {}, score: -1 };
    
    while (attempts < maxAttempts) {
        attempts++;
        
        // Generate a random sequence
        sequence = [];
        for (let i = 1; i <= 90; i++) {
            sequence.push(i);
        }
        // Shuffle the sequence
        for (let i = sequence.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [sequence[i], sequence[j]] = [sequence[j], sequence[i]];
        }
        
        // Simulate the game with this sequence
        const tempWinners = {};
        const calledNumbers = [];
        const playerWinCounts = {};
        gameState.players.forEach(p => playerWinCounts[p.name] = 0);
        
        // Simulate calling numbers in sequence
        for (const num of sequence) {
            calledNumbers.push(num);
            
            // Check each game type
            for (const gameType of gameState.gameTypes) {
                // Skip if this game already has winners
                if (tempWinners[gameType]) continue;
                
                // Find all players who complete this pattern with this number
                const completersThisNumber = [];
                
                gameState.players.forEach(player => {
                    const ticket = player.ticket;
                    const ticketNumbers = ticket.flat().filter(n => n > 0);
                    const markedNumbers = ticketNumbers.filter(n => calledNumbers.includes(n));
                    
                    if (checkWinCondition(ticket, markedNumbers, gameType)) {
                        // Special check for house2
                        if (gameType === 'house2') {
                            // Check if this player won house1
                            const house1Winners = tempWinners['house1'] ? tempWinners['house1'].winners : [];
                            if (house1Winners.includes(player.name)) {
                                return; // Skip - same player can't win both
                            }
                        }
                        
                        completersThisNumber.push(player.name);
                    }
                });
                
                // If anyone completed, they ALL win (and split if multiple)
                if (completersThisNumber.length > 0) {
                    tempWinners[gameType] = {
                        winners: completersThisNumber,
                        winningNumber: num,
                        splitBetween: completersThisNumber.length
                    };
                    
                    // Update win counts
                    completersThisNumber.forEach(winner => {
                        playerWinCounts[winner]++;
                    });
                }
            }
        }
        
        // Calculate statistics for this sequence
        const playersWithWins = Object.values(playerWinCounts).filter(count => count > 0).length;
        const everyoneWon = playersWithWins === totalPlayers;
        const majorityWon = playersWithWins >= Math.ceil(totalPlayers * 0.7);
        
// Calculate split win penalty score
let splitWinCount = 0;
for (const [gameType, data] of Object.entries(tempWinners)) {
    if (data.splitBetween > 1) {
        splitWinCount += (data.splitBetween - 1); // More splits = higher penalty
    }
}

// Calculate overall score (higher is better)
// Prioritize: 1) Meeting distribution goal, 2) Fewer split wins
const score = playersWithWins * 1000 - splitWinCount * 10;

// Keep track of best sequence
if (score > bestStats.score || 
    (score === bestStats.score && playersWithWins > bestStats.uniqueWinners)) {
    bestSequence = [...sequence];
    bestWinners = JSON.parse(JSON.stringify(tempWinners));
    bestStats = {
        uniqueWinners: playersWithWins,
        distribution: { ...playerWinCounts },
        splitWins: splitWinCount,
        score: score
    };
}
        
// Check if this sequence meets our criteria
if (distributionMode === 'random' ||
    (distributionMode === 'majority' && majorityWon) ||
    (distributionMode === 'everyone' && everyoneWon)) {
    
    // Count split wins
    let currentSplitCount = 0;
    for (const [gameType, data] of Object.entries(tempWinners)) {
        if (data.splitBetween > 1) {
            currentSplitCount += (data.splitBetween - 1);
        }
    }
    
    // Only accept if this is the best so far or has very few splits
    if (currentSplitCount <= 2 || attempts >= maxAttempts - 10) {
        console.log(`Found suitable sequence after ${attempts} attempts with ${currentSplitCount} split wins`);
        console.log(`${playersWithWins}/${totalPlayers} players won at least once`);
        console.log('Win distribution:', playerWinCounts);
        
        // Convert to the format expected by the rest of the code
        gameState.predeterminedSequence = sequence;
        gameState.predeterminedWinners = {};
        
        for (const [gameType, data] of Object.entries(tempWinners)) {
            // For compatibility, store first winner as "the winner"
            gameState.predeterminedWinners[gameType] = {
                winner: data.winners[0],
                winningNumber: data.winningNumber,
                allWinners: data.winners,
                splitBetween: data.splitBetween
            };
        }
        
        displayPredeterminedWinners();
        return gameState.predeterminedWinners;
    }
}
}
    
    // Use best sequence found
// For "everyone wins" mode, if we didn't achieve the goal, try a different approach
if (distributionMode === 'everyone' && bestStats.uniqueWinners < totalPlayers) {
    console.log('Everyone wins mode failed to ensure all players win. Using fallback algorithm...');
    
    // Use a more directed approach - manually ensure everyone wins
    const ensuredSequence = ensureEveryoneWins();
    if (ensuredSequence) {
        bestSequence = ensuredSequence.sequence;
        bestWinners = ensuredSequence.winners;
        bestStats = ensuredSequence.stats;
    }
}

// Use best sequence found
console.log(`Using best sequence after ${attempts} attempts`);
console.log(`${bestStats.uniqueWinners}/${totalPlayers} players won at least once`);
console.log('Win distribution:', bestStats.distribution);

gameState.predeterminedSequence = bestSequence;
gameState.predeterminedWinners = {};
    
    for (const [gameType, data] of Object.entries(bestWinners)) {
        gameState.predeterminedWinners[gameType] = {
            winner: data.winners[0],
            winningNumber: data.winningNumber,
            allWinners: data.winners,
            splitBetween: data.splitBetween
        };
    }
    
    displayPredeterminedWinners();
    return gameState.predeterminedWinners;
}

// Fallback algorithm to ensure everyone wins at least once
function ensureEveryoneWins() {
    // Create a directed sequence that guarantees everyone wins
    const players = gameState.players;
    const games = gameState.gameTypes;
    const totalPlayers = players.length;
    const totalGames = games.length;
    
    // If we have more games than players, everyone can win
    if (totalGames >= totalPlayers) {
        // Assign one game to each player first
        const sequence = [];
        const winners = {};
        const playerWinCounts = {};
        players.forEach(p => playerWinCounts[p.name] = 0);
        
        // Try to find a sequence that gives each player a win
        let assignedPlayers = new Set();
        
        for (let gameIdx = 0; gameIdx < games.length && assignedPlayers.size < totalPlayers; gameIdx++) {
            const gameType = games[gameIdx];
            
            // Find a player who hasn't won yet
            for (const player of players) {
                if (!assignedPlayers.has(player.name)) {
                    // Find which numbers would make this player win this game
                    const winningNumbers = findWinningNumbersForPlayer(player, gameType, sequence);
                    
                    if (winningNumbers.length > 0) {
                        // Add these numbers to sequence
                        winningNumbers.forEach(num => {
                            if (!sequence.includes(num)) {
                                sequence.push(num);
                            }
                        });
                        
                        // Record the winner
                        winners[gameType] = {
                            winners: [player.name],
                            winningNumber: winningNumbers[winningNumbers.length - 1],
                            splitBetween: 1
                        };
                        
                        assignedPlayers.add(player.name);
                        playerWinCounts[player.name] = 1;
                        break;
                    }
                }
            }
        }
        
        // Fill remaining numbers randomly
        for (let i = 1; i <= 90; i++) {
            if (!sequence.includes(i)) {
                sequence.push(i);
            }
        }
        
        // Shuffle the remaining portion to add randomness
        const fixedLength = Object.keys(winners).length * 5; // Approximate numbers needed for wins
        const remainingPortion = sequence.slice(fixedLength);
        for (let i = remainingPortion.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [remainingPortion[i], remainingPortion[j]] = [remainingPortion[j], remainingPortion[i]];
        }
        sequence.splice(fixedLength, remainingPortion.length, ...remainingPortion);
        
        return {
            sequence: sequence,
            winners: winners,
            stats: {
                uniqueWinners: assignedPlayers.size,
                distribution: playerWinCounts
            }
        };
    }
    
    return null;
}

// Helper function to find numbers needed for a player to win a specific game
function findWinningNumbersForPlayer(player, gameType, existingSequence) {
    const ticket = player.ticket;
    const ticketNumbers = ticket.flat().filter(n => n > 0);
    const neededNumbers = [];
    
    switch (gameType) {
        case 'firstFive':
            // Return first 5 numbers from ticket
            return ticketNumbers.slice(0, 5);
            
        case 'topLine':
            return ticket[0].filter(n => n > 0);
            
        case 'middleLine':
            return ticket[1].filter(n => n > 0);
            
        case 'bottomLine':
            return ticket[2].filter(n => n > 0);
            
        case 'fullHouse':
        case 'house1':
        case 'house2':
            return ticketNumbers;
            
        // Add other game types as needed
        default:
            return [];
    }
}
        // Display predetermined winners
        function displayPredeterminedWinners() {
            const display = document.getElementById('predeterminedWinnersDisplay');
            const list = document.getElementById('predeterminedWinnersList');
            
            if (!gameState.predeterminedWinners || Object.keys(gameState.predeterminedWinners).length === 0) {
                display.style.display = 'none';
                return;
            }
            
            display.style.display = 'none';
            list.innerHTML = '';
            

gameState.gameTypes.forEach(type => {
    const winner = gameState.predeterminedWinners[type];
    if (winner) {
        const item = document.createElement('div');
        item.className = 'predetermined-winner-item';
        
        // Check if multiple winners
        const allWinners = winner.allWinners || [winner.winner];
        let displayText = '';
        
        if (allWinners.length > 1) {
            displayText = `${allWinners.join(', ')} <small>(#${winner.winningNumber} - split)</small>`;
        } else {
            displayText = `${winner.winner} <small>(#${winner.winningNumber})</small>`;
        }
        
        item.innerHTML = `
            <span>${getGameTypeName(type)}</span>
            <span>${displayText}</span>
        `;
        list.appendChild(item);
    }
});

const showBtn = document.getElementById('showWinnersBtn');
if (showBtn) {
    showBtn.style.display = 'inline-block';
}
}
// Simple toggle for winners list
function toggleWinnersList() {
    const display = document.getElementById('predeterminedWinnersDisplay');
    if (display) {
        if (display.style.display === 'none') {
            display.style.display = 'block';
        } else {
            display.style.display = 'none';
        }
    }
}
        // Start game
        function startGame() {
            const count = parseInt(document.getElementById('playerCount').value);
            const sequenceMode = document.querySelector('input[name="sequenceMode"]:checked').value;
            
            // Reset game state
            gameState = {
                gameTypes: [],
                players: [],
                calledNumbers: [],
                winners: {},
                isAutoPlay: false,
                autoPlayInterval: null,
                tickets: {},
                prizes: {},
                kittyAmount: parseFloat(document.getElementById('kittyAmount').value) || 0,
                distributionMode: document.getElementById('distributionMode').value,
                glowDuration: parseInt(document.getElementById('glowDuration').value) || 5,
                adminPopupDuration: parseInt(document.getElementById('adminPopupDuration').value) || 5,
                playerPopupDuration: parseInt(document.getElementById('playerPopupDuration').value) || 5,
                confettiPlayer: document.getElementById('confettiPlayer').checked,
                confettiAdmin: document.getElementById('confettiAdmin').checked,
                sequenceMode: sequenceMode,
                predeterminedSequence: [],
                predeterminedWinners: {},
                cacheDuration: parseInt(document.getElementById('cacheDuration').value) || 30,
                rageClickEnabled: document.getElementById('rageClickEnabled').checked,
                rageClickThreshold: parseInt(document.getElementById('rageClickThreshold').value) || 3,
winnerDistribution: document.querySelector('input[name="winnerDistribution"]:checked').value,
                passKey1: generatePassKey(),  // Generate new pass key
                passKey2: generatePassKey(),
ticketExpiryValue: parseInt(document.getElementById('ticketExpiry').value) || 0,
ticketExpiryUnit: document.getElementById('ticketExpiryUnit').value || 'hours',
notificationTheme: document.getElementById('notificationTheme').value || 'default', 
celebrationEffect: document.getElementById('celebrationEffect').value || 'confetti'              
};
            
            // Collect selected game types and prizes
            allGameTypes.forEach(gameType => {
                const checkbox = document.getElementById(gameType.id);
                if (checkbox && checkbox.checked) {
                    gameState.gameTypes.push(gameType.id);
                    const prizeInput = document.getElementById(`prize_${gameType.id}`);
                    gameState.prizes[gameType.id] = parseInt(prizeInput.value) || 0;
                }
            });
            
            if (gameState.gameTypes.length === 0) {
                alert('Please select at least one game type!');
                return;
            }
            
            // Initialize winners
            gameState.gameTypes.forEach(type => {
                gameState.winners[type] = {
                    list: [],
                    winningNumbers: {} // Track which number each winner won on
                };
            });
            
// Collect players and generate tickets
let hasValidPlayers = false;
const teamPlayers = [];
const usedNames = new Set();
const usedPhones = new Set();

for (let i = 1; i <= count; i++) {
    const nameInput = document.getElementById(`playerName${i}`);
    const phoneInput = document.getElementById(`playerPhone${i}`);
    
    if (nameInput && phoneInput) {
        const name = nameInput.value.trim();
        const phone = phoneInput.value.trim();
        
        if (name && phone) {
            // Check for duplicate name
            if (usedNames.has(name.toLowerCase())) {
                alert(`Duplicate name found: "${name}". Each player must have a unique name.`);
                nameInput.focus();
                return;
            }
            
            // Check for duplicate phone
            if (usedPhones.has(phone)) {
                alert(`Duplicate phone number found: "${phone}". Each player must have a unique phone number.`);
                phoneInput.focus();
                return;
            }
            
            // Validate phone contains only numbers
            if (!/^\d+$/.test(phone)) {
                alert(`Invalid phone number: "${phone}". Phone number must contain only digits.`);
                phoneInput.focus();
                return;
            }
            
            hasValidPlayers = true;
            usedNames.add(name.toLowerCase());
            usedPhones.add(phone);
            
            const ticket = generateTicket();
            gameState.players.push({ name, phone, ticket });
            gameState.tickets[phone] = { name, ticket, marked: [] };
            teamPlayers.push({ name, phone });
        }
    }
}
            
            if (!hasValidPlayers) {
                alert('Please add at least one player with name and phone!');
                return;
            }
            
            // Determine winners if predetermined mode
            if (sequenceMode === 'predetermined') {
                determinePredeterminedWinners();
            }
            
                // Save team and game configuration if requested
                const storeTeam = document.getElementById('storeTeam').checked;
                const storeHours = parseInt(document.getElementById('storeHours').value) || 0;
                
                if (storeTeam && storeHours > 0) {
                    const now = new Date().getTime();
                    const expiry = now + (storeHours * 60 * 60 * 1000);
                    
                    // Store complete game configuration
                    const gameConfig = {
                        players: teamPlayers,
                        gameTypes: gameState.gameTypes,
                        prizes: gameState.prizes,
                        kittyAmount: gameState.kittyAmount,
                        distributionMode: gameState.distributionMode,
                        glowDuration: gameState.glowDuration,
                        adminPopupDuration: gameState.adminPopupDuration,
                        playerPopupDuration: gameState.playerPopupDuration,
                        confettiPlayer: gameState.confettiPlayer,
                        confettiAdmin: gameState.confettiAdmin,
                        sequenceMode: gameState.sequenceMode,
                        cacheDuration: gameState.cacheDuration,
                        rageClickEnabled: gameState.rageClickEnabled,
                        rageClickThreshold: gameState.rageClickThreshold,
                        expiry: expiry
                    };
                    
                    localStorage.setItem('housieTeam', JSON.stringify(gameConfig));
                }
                
                // Save game state
                saveGameState();
                
                // Send tickets via WhatsApp
                sendTickets();
            
            // Show admin dashboard
            hideAll();
            document.getElementById('adminDashboard').classList.remove('hidden');
            
            // Display predetermined winners if applicable
            if (sequenceMode === 'predetermined') {
                displayPredeterminedWinners();
            }
            
            // Update pass keys display in dashboard
            if (gameState.rageClickEnabled) {
                document.getElementById('passKey1Dashboard').textContent = gameState.passKey1;
                document.getElementById('passKey2Dashboard').textContent = gameState.passKey2;
                document.getElementById('rageClickPassKeys').style.display = 'block';
            }
            
            // Initialize board
            initNumberBoard();
            updateAdminDisplay();
        }

        // Send tickets via WhatsApp
        function sendTickets() {
            // Create a container to show all share links
            const shareModal = document.createElement('div');
            shareModal.className = 'modal';
            shareModal.style.display = 'flex';
            
            const modalContent = document.createElement('div');
            modalContent.className = 'modal-content';
            modalContent.innerHTML = '<h2>Share Tickets</h2>';
            
            // Add compression stats
            const statsDiv = document.createElement('div');
            statsDiv.style.cssText = 'background: #f0fdf4; padding: 1rem; border-radius: 0.5rem; margin-bottom: 1rem; border: 1px solid #bbf7d0;';
            
            let totalOriginalSize = 0;
            let totalCompressedSize = 0;
            
            const shareList = document.createElement('div');
            shareList.style.maxHeight = '400px';
            shareList.style.overflowY = 'auto';
            
            gameState.players.forEach((player, index) => {
                // Encode ticket data in URL
                const ticketData = {
                    name: player.name,
                    phone: player.phone,
                    ticket: player.ticket,
                    games: gameState.gameTypes,
                    prizes: gameState.prizes,
                    sequenceMode: gameState.sequenceMode,
                    rageClickEnabled: gameState.rageClickEnabled,
                    rageClickThreshold: gameState.rageClickThreshold,
                    passKey1: gameState.passKey1,
                    passKey2: gameState.passKey2,
                    expiryTime: 0,  // Will be set below
notificationTheme: gameState.notificationTheme || 'default', 
    celebrationEffect: gameState.celebrationEffect || 'confetti',  
playerPopupDuration: gameState.playerPopupDuration || 5
                };

// Set expiry time based on unit
const expiryValue = parseInt(document.getElementById('ticketExpiry').value) || 0;
const expiryUnit = document.getElementById('ticketExpiryUnit').value || 'hours';

if (expiryValue > 0) {
    if (expiryUnit === 'minutes') {
        ticketData.expiryTime = Date.now() + (expiryValue * 60 * 1000);
    } else {
        ticketData.expiryTime = Date.now() + (expiryValue * 60 * 60 * 1000);
    }
}
                // Add predetermined data if available
                if (gameState.sequenceMode === 'predetermined') {
                    ticketData.predeterminedSequence = gameState.predeterminedSequence;
                    ticketData.predeterminedWinners = gameState.predeterminedWinners;
                }
                
                // Calculate sizes
                const originalSize = btoa(JSON.stringify(ticketData)).length;
                const encodedData = encodeTicketData(ticketData);
                const compressedSize = encodedData.length;
                
                totalOriginalSize += originalSize;
                totalCompressedSize += compressedSize;
                
                const ticketUrl = `https://chopra3sahil.github.io/tembola/?data=${encodedData}`;
                
                // Create share item
                const shareItem = document.createElement('div');
                shareItem.style.cssText = 'background: #f9fafb; padding: 1rem; margin-bottom: 0.5rem; border-radius: 0.75rem; border: 1px solid #e5e7eb;';
                
                // Create content
                const content = document.createElement('div');
                content.innerHTML = `<strong>${player.name}</strong> - ${player.phone}<br>`;
                
                // Show URL length reduction
                const reduction = Math.round((1 - compressedSize / originalSize) * 100);
                content.innerHTML += `<small style="color: #10b981;">URL compressed by ${reduction}% (${compressedSize} chars)</small>`;
                
                shareItem.appendChild(content);
                
                // Share button
                const shareBtn = document.createElement('button');
                shareBtn.className = 'btn btn-success';
                shareBtn.style.marginTop = '0.75rem';
                shareBtn.textContent = 'Share on WhatsApp';
                shareBtn.onclick = function() {
                    shareOnWhatsApp(player.name, player.phone, encodedData);
                };
                shareItem.appendChild(shareBtn);
                
                // Copy button
                const copyBtn = document.createElement('button');
                copyBtn.className = 'btn btn-secondary';
                copyBtn.style.marginTop = '0.75rem';
                copyBtn.style.marginLeft = '0.5rem';
                copyBtn.textContent = 'Copy Link';
                copyBtn.onclick = function() {
                    copyLink(ticketUrl);
                };
                shareItem.appendChild(copyBtn);
                
                shareList.appendChild(shareItem);
            });
            
            // Update stats
            const avgReduction = Math.round((1 - totalCompressedSize / totalOriginalSize) * 100);
            statsDiv.innerHTML = `
                <div style="text-align: center;">
                    <div style="font-size: 0.875rem; color: #059669; font-weight: 600;">🎉 URL Compression Active</div>
                    <div style="font-size: 0.75rem; color: #047857; margin-top: 0.25rem;">
                        Average reduction: ${avgReduction}% | Saved ${totalOriginalSize - totalCompressedSize} characters total
                    </div>
                </div>
            `;
            
            modalContent.appendChild(statsDiv);
            modalContent.appendChild(shareList);
            
            // Add group message button
            const groupBtn = document.createElement('button');
            groupBtn.className = 'btn btn-warning';
            groupBtn.textContent = 'Generate Group Message';
            groupBtn.onclick = generateGroupMessage;
            groupBtn.style.marginTop = '1rem';
            modalContent.appendChild(groupBtn);
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'btn btn-primary';
            closeBtn.textContent = 'Done';
            closeBtn.onclick = () => shareModal.remove();
            closeBtn.style.marginTop = '0.5rem';
            
            modalContent.appendChild(closeBtn);
            shareModal.appendChild(modalContent);
            document.body.appendChild(shareModal);
        }
        
        // Generate group message
        function generateGroupMessage() {
            let message = `🎱 *HOUSIE GAME TICKETS* 🎱\n\n`;
            message += `Welcome to our Housie Game!\n\n`;
            message += `*Prize Pool: ₹${gameState.kittyAmount}*\n\n`;
            
            message += `📋 *Player Tickets:*\n`;
            message += `━━━━━━━━━━━━━━━━\n\n`;
            
            gameState.players.forEach((player, index) => {
                const ticketData = {
                    name: player.name,
                    phone: player.phone,
                    ticket: player.ticket,
                    games: gameState.gameTypes,
                    prizes: gameState.prizes,
                    sequenceMode: gameState.sequenceMode,
                    rageClickEnabled: gameState.rageClickEnabled,
                    rageClickThreshold: gameState.rageClickThreshold,
                    passKey1: gameState.passKey1,
                    passKey2: gameState.passKey2
                };
                
                // Add predetermined data if available
                if (gameState.sequenceMode === 'predetermined') {
                    ticketData.predeterminedSequence = gameState.predeterminedSequence;
                    ticketData.predeterminedWinners = gameState.predeterminedWinners;
                }
                
                // Use optimized encoding
                const encodedData = encodeTicketData(ticketData);
                const ticketUrl = `https://chopra3sahil.github.io/tembola/?data=${encodedData}`;
                
                message += `${index + 1}. *${player.name}*\n`;
                message += `📱 ${player.phone}\n`;
                message += `🎟️ ${ticketUrl}\n\n`;
            });
            
            message += `━━━━━━━━━━━━━━━━\n`;
            message += `💰 *Game Prizes:*\n`;
            
            gameState.gameTypes.forEach(type => {
                const prize = gameState.prizes[type] || 0;
                message += `• ${getGameTypeName(type)}: ₹${prize}\n`;
            });
            
            message += `\n✨ Good luck to all players! ✨`;
            
            // Create modal to show group message
            const msgModal = document.createElement('div');
            msgModal.className = 'modal';
            msgModal.style.display = 'flex';
            msgModal.style.zIndex = '1002';
            
            const msgContent = document.createElement('div');
            msgContent.className = 'modal-content';
            msgContent.innerHTML = '<h2>Group Message</h2>';
            
            const msgDiv = document.createElement('div');
            msgDiv.className = 'group-message-container';
            msgDiv.textContent = message;
            msgContent.appendChild(msgDiv);
            
            const btnContainer = document.createElement('div');
            btnContainer.style.display = 'flex';
            btnContainer.style.gap = '0.5rem';
            btnContainer.style.marginTop = '1rem';
            
            const copyMsgBtn = document.createElement('button');
            copyMsgBtn.className = 'btn btn-success';
            copyMsgBtn.textContent = 'Copy Message';
            copyMsgBtn.onclick = () => {
                navigator.clipboard.writeText(message).then(() => {
                    alert('Message copied to clipboard!');
                });
            };
            btnContainer.appendChild(copyMsgBtn);
            
            const closeMsgBtn = document.createElement('button');
            closeMsgBtn.className = 'btn btn-secondary';
            closeMsgBtn.textContent = 'Close';
            closeMsgBtn.onclick = () => msgModal.remove();
            btnContainer.appendChild(closeMsgBtn);
            
            msgContent.appendChild(btnContainer);
            msgModal.appendChild(msgContent);
            document.body.appendChild(msgModal);
        }
        
        // Share individual ticket on WhatsApp
        function shareOnWhatsApp(name, phone, encodedData) {
            const ticketUrl = `https://chopra3sahil.github.io/tembola/?data=${encodedData}`;
            let message = `Hello ${name}! 🎱\n\nYour Housie ticket is ready!\n\n`;
            
            message += `Click here to view your ticket:\n${ticketUrl}\n\nGood luck! 🍀`;
            
            const whatsappUrl = `https://wa.me/${phone}?text=${encodeURIComponent(message)}`;
            window.open(whatsappUrl, '_blank');
        }
        
        // Copy link to clipboard
        function copyLink(url) {
            navigator.clipboard.writeText(url).then(() => {
                alert('Link copied to clipboard!');
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = url;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Link copied to clipboard!');
            });
        }

        // Initialize number board
        function initNumberBoard() {
            const board = document.getElementById('numberBoard');
            if (!board) return;
            
            board.innerHTML = '';
            
            for (let i = 1; i <= 90; i++) {
                const cell = document.createElement('div');
                cell.className = 'number-cell';
                cell.textContent = i;
                cell.id = `num-${i}`;
                board.appendChild(cell);
            }
        }

        // Call number
        function callNumber() {
            if (gameState.sequenceMode === 'predetermined') {
                // Use predetermined sequence
                const nextIndex = gameState.calledNumbers.length;
                if (nextIndex >= gameState.predeterminedSequence.length) {
                    alert('All numbers have been called!');
                    return;
                }
                
                const number = gameState.predeterminedSequence[nextIndex];
                gameState.calledNumbers.push(number);
                
                // Update UI
                const numCell = document.getElementById(`num-${number}`);
                if (numCell) numCell.classList.add('called');
                
                // Add animation to current number display
                const currentNumberEl = document.getElementById('currentNumber');
                currentNumberEl.textContent = number;
                currentNumberEl.classList.add('number-calling');
                setTimeout(() => currentNumberEl.classList.remove('number-calling'), 1000);
                
                document.getElementById('calledCount').textContent = gameState.calledNumbers.length;
                
                // Update last numbers
                const lastTwenty = gameState.calledNumbers.slice(-20).reverse();
document.getElementById('lastNumbers').textContent = 
    lastTwenty.length > 1 ? `Last numbers: ${lastTwenty.join(', ')}` : '';
                
                // Speak number
                speakNumber(number);
                
                // Check for automatic winners (admin only)
                checkAutomaticWinners();
                
                // Save state
                saveGameState();
            } else {
                // Traditional random mode
                const availableNumbers = [];
                for (let i = 1; i <= 90; i++) {
                    if (!gameState.calledNumbers.includes(i)) {
                        availableNumbers.push(i);
                    }
                }
                
                if (availableNumbers.length === 0) {
                    alert('All numbers have been called!');
                    return;
                }
                
                const number = availableNumbers[Math.floor(Math.random() * availableNumbers.length)];
                gameState.calledNumbers.push(number);
                
                // Update UI
                const numCell = document.getElementById(`num-${number}`);
                if (numCell) numCell.classList.add('called');
                
                // Add animation to current number display
                const currentNumberEl = document.getElementById('currentNumber');
                currentNumberEl.textContent = number;
                currentNumberEl.classList.add('number-calling');
                setTimeout(() => currentNumberEl.classList.remove('number-calling'), 1000);
                
                document.getElementById('calledCount').textContent = gameState.calledNumbers.length;
                
                // Update last numbers
               const lastTwenty = gameState.calledNumbers.slice(-20).reverse();
document.getElementById('lastNumbers').textContent = 
    lastTwenty.length > 1 ? `Last numbers: ${lastTwenty.join(', ')}` : '';
                
                // Speak number
                speakNumber(number);
                
                // Check for automatic winners (admin only)
                checkAutomaticWinners();
                
                // Save state
                saveGameState();
            }
        }
        
        // Check automatic winners (for admin view only)
        function checkAutomaticWinners() {
            let newWinners = [];
            const currentNumber = gameState.calledNumbers[gameState.calledNumbers.length - 1];
            
// For predetermined mode, check against predetermined winners
if (gameState.sequenceMode === 'predetermined') {
    gameState.gameTypes.forEach(type => {
        const predeterminedWinner = gameState.predeterminedWinners[type];
        if (predeterminedWinner && predeterminedWinner.winningNumber === currentNumber) {
            // This is the winning number for this game
            if (!gameState.winners[type]) {
                gameState.winners[type] = {
                    list: [],
                    winningNumbers: {}
                };
            }
            
            // Check if multiple winners exist (allWinners array)
            const winnersToAdd = predeterminedWinner.allWinners || [predeterminedWinner.winner];
            
            // Add all winners
            gameState.winners[type].list = winnersToAdd;
            gameState.winners[type].winningNumbers[currentNumber] = winnersToAdd;
            
            // Add all winners to newWinners
            winnersToAdd.forEach(winner => {
                newWinners.push({
                    player: winner,
                    type: getGameTypeName(type)
                });
            });
            
            // Show confetti for wins if enabled for admin
            if (gameState.confettiAdmin) {
                showCelebration();
            }
        }
    });
} else if (gameState.sequenceMode === 'random') {
// First, check each game type
gameState.gameTypes.forEach(type => {
    // Collect ALL players who complete this pattern on the current number
    const playersCompletingNow = [];
    
    gameState.players.forEach(player => {
        const allTicketNumbers = player.ticket.flat().filter(n => n > 0);
        const markedFromCalled = allTicketNumbers.filter(n => gameState.calledNumbers.includes(n));
        
        // Check if this player completes the pattern
        if (checkWinCondition(player.ticket, markedFromCalled, type)) {
            // For house2, check special conditions
            if (type === 'house2') {
                // Check if house1 has a winner
                let house1HasWinner = false;
                if (gameState.winners['house1']) {
                    const house1Winners = Array.isArray(gameState.winners['house1']) ? 
                        gameState.winners['house1'] : (gameState.winners['house1'].list || []);
                    house1HasWinner = house1Winners.length > 0;
                    
                    // Check if THIS player won house1
                    if (house1Winners.includes(player.name)) {
                        return; // Same player can't win both house1 and house2
                    }
                }
                
                if (!house1HasWinner) {
                    return; // Can't win house2 before house1
                }
            }
            
            // Check if this player already won this type on a previous number
            let alreadyWon = false;
            if (gameState.winners[type]) {
                const winnersList = Array.isArray(gameState.winners[type]) ? 
                    gameState.winners[type] : (gameState.winners[type].list || []);
                alreadyWon = winnersList.includes(player.name);
            }
            
            if (!alreadyWon) {
                playersCompletingNow.push(player.name);
            }
        }
    });
    
    // Now check if this game already has winners from previous numbers
    if (gameState.winners[type]) {
        // Convert old format if needed
        if (Array.isArray(gameState.winners[type])) {
            gameState.winners[type] = {
                list: gameState.winners[type],
                winningNumbers: {}
            };
            if (gameState.winners[type].list.length > 0) {
                gameState.winners[type].winningNumbers['unknown'] = gameState.winners[type].list;
            }
        }
        
        // Check if someone already won on a different number
        let hasWinnersOnDifferentNumber = false;
        if (gameState.winners[type].winningNumbers) {
            for (const [num, winners] of Object.entries(gameState.winners[type].winningNumbers)) {
                if (num !== currentNumber.toString() && winners && winners.length > 0) {
                    hasWinnersOnDifferentNumber = true;
                    break;
                }
            }
        }
        
        // If someone won on a different number, no new winners allowed (except house2)
        if (hasWinnersOnDifferentNumber && type !== 'house2') {
            return; // Skip this game type
        }
    }
    
    // Add all players who completed the pattern on this number
    if (playersCompletingNow.length > 0) {
        // Initialize winners for this type if needed
        if (!gameState.winners[type]) {
            gameState.winners[type] = {
                list: [],
                winningNumbers: {}
            };
        }
        
        // Add all new winners
        playersCompletingNow.forEach(playerName => {
            gameState.winners[type].list.push(playerName);
            
            newWinners.push({
                player: playerName,
                type: getGameTypeName(type)
            });
        });
        
        // Track which number these winners won on
        gameState.winners[type].winningNumbers[currentNumber] = playersCompletingNow;
        
        // Show confetti for wins if enabled for admin
        if (gameState.confettiAdmin && playersCompletingNow.length > 0) {
            showCelebration();
        }
    }
});
                }
           
// Show notification only for NEW winners
if (newWinners.length > 0) {
    const popupDuration = gameState.adminPopupDuration || gameState.glowDuration || 5;
    
    // Group winners by game type to handle multiple winners
    const winnersByType = {};
    newWinners.forEach(winner => {
        if (!winnersByType[winner.type]) {
            winnersByType[winner.type] = [];
        }
        winnersByType[winner.type].push(winner.player);
    });
    
    // Create notification for each game type
   // Create notification for each game type
Object.entries(winnersByType).forEach(([gameType, winners], index) => {
    setTimeout(() => {

const celebrationDiv = document.createElement('div');
celebrationDiv.className = `game-notification winner-celebration ${getNotificationThemeClass()}`;

        celebrationDiv.style.setProperty('--duration', `${popupDuration}s`);
        
        // Get prize amount for this game
        const gameTypeId = gameState.gameTypes.find(t => getGameTypeName(t) === gameType);
        const prize = gameTypeId ? (gameState.prizes[gameTypeId] || 0) : 0;
        
        // ALWAYS show player names
        let celebrationText = `${gameType} - ${winners.join(', ')}`;
        let prizeText = `₹${prize}`;
        
        if (winners.length > 1) {
            const splitPrize = Math.round(prize / winners.length);
            prizeText = `₹${splitPrize} each`;
        }            
            celebrationDiv.innerHTML = `
                <span class="icon">🎉</span>
                <span class="text">${celebrationText}</span>
                <span class="amount">${prizeText}</span>
                <div class="notification-progress"></div>
            `;
            
            document.body.appendChild(celebrationDiv);
            
            // Add to notification stack
            addNotificationToStack(celebrationDiv);
            
            // Remove after duration
            setTimeout(() => {
                celebrationDiv.style.animation = 'slideDown 0.2s ease-in forwards';
                setTimeout(() => {
                    removeNotificationFromStack(celebrationDiv);
                    celebrationDiv.remove();
                }, 200);
            }, popupDuration * 1000);
        }, index * 300); // Stagger notifications if multiple games
    });
}
}
       // Speak number
       function speakNumber(number) {
           if ('speechSynthesis' in window) {
               const voiceMode = document.querySelector('input[name="voiceMode"]:checked').value;
               let textToSpeak = number.toString();
               
               if (voiceMode === 'words') {
                   // Convert number to words (e.g., 42 becomes "four two")
                   textToSpeak = number.toString().split('').map(digit => numberWords[digit]).join(' ');
               } else if (voiceMode === 'full') {
                   // Full style - fixed for single digit numbers
                   const digits = number.toString().split('');
                   if (digits.length === 1) {
                       // For single digit, just say the number
                       textToSpeak = number.toString();
                   } else {
                       // For multi-digit, say digits followed by the number
                       const digitWords = digits.map(digit => numberWords[digit]).join(' ');
                       textToSpeak = `${digitWords} ${number}`;
                   }
               }
               
               const utterance = new SpeechSynthesisUtterance(textToSpeak);
               
               // Get selected voice
               const selectedVoiceName = document.getElementById('voiceSelect').value;
               const voices = speechSynthesis.getVoices();
               const selectedVoice = voices.find(voice => voice.name === selectedVoiceName);
               
               if (selectedVoice) {
                   utterance.voice = selectedVoice;
               }
               
               // Set speech parameters for clarity
               utterance.rate = 0.9; // Slightly slower for clarity
               utterance.pitch = 1.0;
               utterance.volume = 1.0;
               
               speechSynthesis.speak(utterance);
           }
       }

       // Toggle auto play
       function toggleAutoPlay() {
           gameState.isAutoPlay = !gameState.isAutoPlay;
           
           if (gameState.isAutoPlay) {
               const interval = parseInt(document.getElementById('autoInterval').value) * 1000;
               gameState.autoPlayInterval = setInterval(callNumber, interval);
               document.getElementById('autoPlayText').textContent = 'Stop Auto';
           } else {
               clearInterval(gameState.autoPlayInterval);
               document.getElementById('autoPlayText').textContent = 'Auto Play';
           }
       }

       // Join with phone
       function joinWithPhone() {
           const phone = document.getElementById('joinPhone').value.trim();
           
           // Get the saved game state
           const savedGame = localStorage.getItem('housieGame');
           if (!savedGame) {
               alert('No active game found!');
               return;
           }
           
           const savedState = JSON.parse(savedGame);
           
           // Find the player's ticket
           let playerData = null;
           let playerTicket = null;
           
           // Search in saved tickets
           for (const [key, value] of Object.entries(savedState.tickets || {})) {
               const cleanKey = key.replace(/[\s\-\(\)]/g, '');
               const cleanPhone = phone.replace(/[\s\-\(\)]/g, '');
               if (cleanKey === cleanPhone || key === phone) {
                   playerData = value;
                   break;
               }
           }
           
           // Also search in players array for ticket
           if (!playerTicket && savedState.players) {
               const player = savedState.players.find(p => {
                   const cleanPlayerPhone = p.phone.replace(/[\s\-\(\)]/g, '');
                   const cleanPhone = phone.replace(/[\s\-\(\)]/g, '');
                   return cleanPlayerPhone === cleanPhone || p.phone === phone;
               });
               if (player) {
                   playerTicket = player.ticket;
                   if (!playerData) {
                       playerData = { name: player.name, ticket: player.ticket };
                   }
               }
           }
           
           if (!playerData || !playerData.ticket) {
               alert('No ticket found for this phone number! Please check the number and try again.');
               return;
           }
           
           // Show player view
           hideAll();
           document.getElementById('playerView').classList.remove('hidden');
           document.getElementById('playerName').textContent = playerData.name;
           
           // Store player name and mode for later use
           window.playerName = playerData.name;
           window.sequenceMode = savedState.sequenceMode || 'random';
           window.rageClickEnabled = savedState.rageClickEnabled;
           window.rageClickThreshold = savedState.rageClickThreshold || 3;
           window.passKey1 = savedState.passKey1 || '';
           window.passKey2 = savedState.passKey2 || '';
           
           // Store predetermined data if available
           if (savedState.sequenceMode === 'predetermined') {
               window.predeterminedSequence = savedState.predeterminedSequence;
               window.predeterminedWinners = savedState.predeterminedWinners;
           }
           
           // Display the ticket
           displayPlayerTicket(playerData.ticket, phone);
       }

       // Display player ticket
       function displayPlayerTicket(ticket, phone) {
           const ticketDiv = document.getElementById('playerTicket');
           ticketDiv.innerHTML = '';
           
           // Add theme selector
           const themeSelector = document.createElement('div');
           themeSelector.className = 'theme-selector';
           themeSelector.innerHTML = `
               <button class="theme-btn active" onclick="changeTheme('default')">Default</button>
               <button class="theme-btn" onclick="changeTheme('classic')">Classic</button>
               <button class="theme-btn" onclick="changeTheme('neon')">Neon</button>
               <button class="theme-btn" onclick="changeTheme('ocean')">Ocean</button>
               <button class="theme-btn" onclick="changeTheme('vibrant')">Vibrant</button>
               <button class="theme-btn" onclick="changeTheme('sky')">Sky</button>
               <button class="theme-btn" onclick="changeTheme('kids')">Kids</button>
               <button class="theme-btn" onclick="changeTheme('stargazer')">stargazer</button>
<button class="theme-btn" onclick="changeTheme('quantum')">Quantum</button>
               <button class="theme-btn" onclick="changeTheme('jungle')">Jungle</button>
           `;
           ticketDiv.appendChild(themeSelector);
           
           // Create ticket container
           const ticketContainer = document.createElement('div');
           ticketContainer.className = 'ticket';
           ticketContainer.id = 'ticketContainer';
           ticketContainer.innerHTML = '<div class="ticket-header"><h3>Your Ticket</h3></div>';
           
           // Add refresh warning
           window.addEventListener('beforeunload', function(e) {
               if (window.sessionMarked && window.sessionMarked.length > 0) {
                   e.preventDefault();
                   e.returnValue = '';
               }
           });
           
           const grid = document.createElement('div');
           grid.className = 'ticket-grid';
           
           // Load cached marked numbers
           const cachedMarked = loadTicketCache(phone);
           
           // Check if this is the same session (page refresh) or a new session
           const currentSessionKey = `ticket_session_${phone}_${Date.now()}`;
           const isSameSession = window.cachedSessionId === window.currentSessionKey;
           
           // Get or initialize marked numbers for this session
           if (!window.sessionMarked || window.sessionMarked.length === 0) {
               window.sessionMarked = cachedMarked;
           }
           
           // Store current session key
           window.currentSessionKey = currentSessionKey;
           
           // Reset rage click data for this session
           // Load cached lock state first from loadTicketCache
           if (!rageClickData[phone]) {
               rageClickData[phone] = {
                   clicks: [],
                   isLocked: false
               };
           }
           
           // Don't reset warnings if same session
           if (!isSameSession && !rageClickWarnings[phone]) {
               rageClickWarnings[phone] = 0;
           }
           
           // Check if ticket should be locked from cache
           if (rageClickData[phone] && rageClickData[phone].isLocked) {
               // Re-lock the ticket after loading
               setTimeout(() => {
                   lockTicket();
               }, 100);
           }
           
           ticket.forEach((row, rowIndex) => {
               row.forEach((num, colIndex) => {
                   const cell = document.createElement('div');
                   cell.className = 'ticket-cell';
                   if (num > 0) {
                       cell.textContent = num;
                       cell.onclick = () => toggleMarkWithCheck(num, cell, phone);
                       
                       // Check if already marked in this session
                       if (window.sessionMarked.includes(num)) {
                           cell.classList.add('marked');
                           
                           // For vibrant theme, add a random color
                           const isVibrantTheme = document.getElementById('ticketContainer')?.classList.contains('theme-vibrant');
                           if (isVibrantTheme) {
                               const randomColor = Math.floor(Math.random() * 8) + 1;
                               cell.classList.add(`color-${randomColor}`);
                           }
                       }
                   }
                   grid.appendChild(cell);
               });
           });
           
           ticketContainer.appendChild(grid);
           ticketDiv.appendChild(ticketContainer);
           
           // Get selected game types from saved state
           const savedGame = localStorage.getItem('housieGame');
           let selectedGameTypes = [];
           let gamePrizes = {};
           if (savedGame) {
               const savedState = JSON.parse(savedGame);
               selectedGameTypes = savedState.gameTypes || [];
               gamePrizes = savedState.prizes || {};
               
               // Store predetermined data
               if (savedState.sequenceMode === 'predetermined') {
                   window.predeterminedSequence = savedState.predeterminedSequence;
                   window.predeterminedWinners = savedState.predeterminedWinners;
               }
               
               // Store sequence mode
               window.sequenceMode = savedState.sequenceMode || 'random';
           }
           
           // Store for use in claims
           window.selectedGames = selectedGameTypes;
           window.gamePrizes = gamePrizes;
           window.currentTicket = ticket;
           window.currentPhone = phone;
           
           // Add progress section for predetermined and random modes
           if (window.sequenceMode !== 'manual') {
               const progressSection = document.createElement('div');
               progressSection.id = 'progressSection';
               progressSection.style.cssText = 'margin-top: 1.5rem; padding: 1rem; background: #f9fafb; border-radius: 0.75rem;';
               ticketDiv.appendChild(progressSection);
               
               // Initial progress update
               updateProgress();
               
               // Check for automatic wins only if NOT a page refresh
               if (!isSameSession && cachedMarked.length > 0) {
                   checkAutomaticWinsForPlayer();
               }
           } else {
               // Manual mode - add claim buttons
               const claimSection = document.createElement('div');
               claimSection.className = 'claim-section';
               claimSection.innerHTML = '<h4>Click to claim when you complete a pattern:</h4>';
               
               const claimButtonsDiv = document.createElement('div');
               claimButtonsDiv.id = 'claimButtons';
               
               selectedGameTypes.forEach(type => {
                   const btn = document.createElement('button');
                   btn.className = 'claim-button disabled';
                   btn.textContent = `${getGameTypeName(type)} (₹${gamePrizes[type]})`;
                   btn.id = `claim_${type}`;
                   btn.onclick = () => claimWin(type);
                   claimButtonsDiv.appendChild(btn);
               });
               
               claimSection.appendChild(claimButtonsDiv);
               ticketDiv.appendChild(claimSection);
               
               // Update claim buttons initially
               updateClaimButtons();
           }
       }

       // Display player ticket for direct URL access
       function displayPlayerTicketDirect(ticket, phone) {
           window.currentPhone = phone;
           const ticketDiv = document.getElementById('playerTicket');
           ticketDiv.innerHTML = '';
           
           // Load cached marked numbers
           const cachedMarked = loadTicketCache(phone);
           window.sessionMarked = cachedMarked;
           
           const sessionKey = `ticket_session_${phone}_${Date.now()}`;
           window.currentSessionKey = sessionKey;
           
           // Check if this is the same session
           const isSameSession = window.cachedSessionId === sessionKey;
           
           // Load cached lock state from loadTicketCache
           if (!rageClickData[phone]) {
               rageClickData[phone] = {
                   clicks: [],
                   isLocked: false
               };
           }
           
           // Don't reset warnings if same session
           if (!isSameSession && !rageClickWarnings[phone]) {
               rageClickWarnings[phone] = 0;
           }
           
           // Check if ticket should be locked from cache
           if (rageClickData[phone] && rageClickData[phone].isLocked) {
               // Re-lock the ticket after DOM is ready
               setTimeout(() => {
                   lockTicket();
               }, 100);
           }
           
           // Add theme selector
           const themeSelector = document.createElement('div');
           themeSelector.className = 'theme-selector';
           themeSelector.innerHTML = `
               <button class="theme-btn active" onclick="changeTheme('default')">Default</button>
               <button class="theme-btn" onclick="changeTheme('classic')">Classic</button>
               <button class="theme-btn" onclick="changeTheme('neon')">Neon</button>
               <button class="theme-btn" onclick="changeTheme('ocean')">Ocean</button>
               <button class="theme-btn" onclick="changeTheme('vibrant')">Vibrant</button>
               <button class="theme-btn" onclick="changeTheme('sky')">Sky</button>
               <button class="theme-btn" onclick="changeTheme('kids')">Kids</button>
               <button class="theme-btn" onclick="changeTheme('stargazer')">stargazer</button>
<button class="theme-btn" onclick="changeTheme('quantum')">Quantum</button>
               <button class="theme-btn" onclick="changeTheme('jungle')">Jungle</button>
           `;
           ticketDiv.appendChild(themeSelector);
           
           // Create ticket container
           const ticketContainer = document.createElement('div');
           ticketContainer.className = 'ticket';
           ticketContainer.id = 'ticketContainer';
           ticketContainer.innerHTML = '<div class="ticket-header"><h3>Your Ticket</h3></div>';
           
           // Add refresh warning
           window.addEventListener('beforeunload', function(e) {
               if (window.sessionMarked && window.sessionMarked.length > 0) {
                   e.preventDefault();
                   e.returnValue = '';
               }
           });
           
           const grid = document.createElement('div');
           grid.className = 'ticket-grid';
           
           window.currentTicket = ticket;
           
           ticket.forEach((row, rowIndex) => {
               row.forEach((num, colIndex) => {
                   const cell = document.createElement('div');
                   cell.className = 'ticket-cell';
                   if (num > 0) {
                       cell.textContent = num;
                       cell.onclick = () => toggleMarkWithCheck(num, cell, phone);
                       
                       // Check if already marked
                       if (window.sessionMarked.includes(num)) {
                           cell.classList.add('marked');
                           
                           // For vibrant theme, add a random color
                           const isVibrantTheme = document.getElementById('ticketContainer')?.classList.contains('theme-vibrant');
                           if (isVibrantTheme) {
                               const randomColor = Math.floor(Math.random() * 8) + 1;
                               cell.classList.add(`color-${randomColor}`);
                           }
                       }
                   }
                   grid.appendChild(cell);
               });
           });
           
           ticketContainer.appendChild(grid);
           ticketDiv.appendChild(ticketContainer);
           
           // Add appropriate section based on mode
           if (window.sequenceMode !== 'manual') {
               // Progress section for predetermined and random modes
               const progressSection = document.createElement('div');
               progressSection.id = 'progressSection';
               progressSection.style.cssText = 'margin-top: 1.5rem; padding: 1rem; background: #f9fafb; border-radius: 0.75rem;';
               ticketDiv.appendChild(progressSection);
               
               // Initial progress update
               updateProgress();
               
               // Check for automatic wins only if NOT a page refresh and has cached numbers
               if (!isSameSession && cachedMarked.length > 0 && window.predeterminedSequence && window.predeterminedWinners) {
                   checkAutomaticWinsForPlayer();
               }
           } else {
               // Manual mode - add claim buttons
               const claimSection = document.createElement('div');
               claimSection.className = 'claim-section';
               claimSection.innerHTML = '<h4>Click to claim when you complete a pattern:</h4>';
               
               const claimButtonsDiv = document.createElement('div');
               claimButtonsDiv.id = 'claimButtons';
               
               window.selectedGames.forEach(type => {
                   const btn = document.createElement('button');
                   btn.className = 'claim-button disabled';
                   btn.textContent = `${getGameTypeName(type)} (₹${window.gamePrizes[type]})`;
                   btn.id = `claim_${type}`;
                   btn.onclick = () => claimWin(type);
                   claimButtonsDiv.appendChild(btn);
               });
               
               claimSection.appendChild(claimButtonsDiv);
               ticketDiv.appendChild(claimSection);
               
               // Update claim buttons initially
               updateClaimButtons();
           }
       }
       
       // Update claim buttons for manual mode
       function updateClaimButtons() {
           if (window.sequenceMode !== 'manual') return;
           
           const marked = window.sessionMarked || [];
           const ticket = window.currentTicket;
           
           window.selectedGames.forEach(type => {
               const btn = document.getElementById(`claim_${type}`);
               if (!btn) return;
               
               // Check if pattern is complete
               const isComplete = checkWinCondition(ticket, marked, type);
               
               // Check win status from saved game
               const savedGame = localStorage.getItem('housieGame');
               let hasWinner = false;
               
               if (savedGame) {
                   const state = JSON.parse(savedGame);
                   if (state.winners && state.winners[type]) {
                       const winnersData = state.winners[type];
                       if (Array.isArray(winnersData) && winnersData.length > 0) {
                           hasWinner = true;
                       } else if (winnersData.list && winnersData.list.length > 0) {
                           hasWinner = true;
                       }
                   }
               }
               
               // Update button state
               btn.classList.remove('active', 'disabled', 'won', 'late');
               
               if (hasWinner) {
                   // Check if this player won
                   const savedGame = JSON.parse(localStorage.getItem('housieGame'));
                   const winnersData = savedGame.winners[type];
                   const winnersList = Array.isArray(winnersData) ? winnersData : (winnersData.list || []);
                   
                   if (winnersList.includes(window.playerName)) {
                       btn.classList.add('won');
                       btn.textContent = `${getGameTypeName(type)} - Won! ₹${window.gamePrizes[type]}`;
                       btn.disabled = true;
                   } else {
                       btn.classList.add('late');
                       btn.textContent = `${getGameTypeName(type)} - Too Late!`;
                       btn.disabled = true;
                   }
               } else if (isComplete) {
                   btn.classList.add('active');
                   btn.disabled = false;
               } else {
                   btn.classList.add('disabled');
                   btn.disabled = true;
               }
           });
       }
       
       // Claim win for manual mode
       function claimWin(type) {
           if (window.sequenceMode !== 'manual') return;
           
           const savedGame = localStorage.getItem('housieGame');
           if (!savedGame) {
               alert('Game session expired!');
               return;
           }
           
           const state = JSON.parse(savedGame);
           const marked = window.sessionMarked || [];
           const ticket = window.currentTicket;
           
           // Verify pattern is complete
           if (!checkWinCondition(ticket, marked, type)) {
               alert('Pattern not complete!');
               return;
           }
           
           // Check if already has winner
           if (state.winners[type]) {
               const winnersData = state.winners[type];
               const winnersList = Array.isArray(winnersData) ? winnersData : (winnersData.list || []);
               
               if (winnersList.length > 0) {
                   alert(`Too late! ${winnersList[0]} already won ${getGameTypeName(type)}!`);
                   updateClaimButtons();
                   return;
               }
           }
           
           // Add winner
           // Add winner
if (!state.winners[type]) {
    state.winners[type] = {
        list: [],
        winningNumbers: {}
    };
}

// Get current number being called (for manual claims, we'll use 'manual' as key)
const currentNumber = state.calledNumbers[state.calledNumbers.length - 1] || 'manual';

state.winners[type].list.push(window.playerName);

// Track winner under the current number
if (!state.winners[type].winningNumbers[currentNumber]) {
    state.winners[type].winningNumbers[currentNumber] = [];
}
state.winners[type].winningNumbers[currentNumber].push(window.playerName);

// Calculate split
const splitCount = state.winners[type].winningNumbers[currentNumber].length;
const originalPrize = window.gamePrizes[type] || 0;
const splitPrize = Math.round(originalPrize / splitCount);
// Track wins for distribution
if (!window.playerWinsTracker) {
    window.playerWinsTracker = {};
}
if (!window.playerWinsTracker[window.playerName]) {
    window.playerWinsTracker[window.playerName] = 0;
}
window.playerWinsTracker[window.playerName]++;
           
           // Save updated stateo
           localStorage.setItem('housieGame', JSON.stringify(state));

// Show winner notification
let popupDuration = 5;
if (window.playerPopupDuration) {
    popupDuration = window.playerPopupDuration;
} else {
    popupDuration = state.playerPopupDuration || state.glowDuration || 5;
}


const celebrationDiv = document.createElement('div');
celebrationDiv.className = `game-notification winner-celebration ${getNotificationThemeClass()}`;
let celebrationText = getGameTypeName(type);
if (splitCount > 1) {
    celebrationText += ` (Split ${splitCount} ways)`;
}
celebrationDiv.innerHTML = `
    <span class="icon">🎉</span>
    <span class="text">${celebrationText}</span>
    <span class="amount">₹${splitPrize}</span>
`;
document.body.appendChild(celebrationDiv);

// Add to notification stack
addNotificationToStack(celebrationDiv);

// Remove after duration
setTimeout(() => {
    celebrationDiv.style.animation = 'slideDown 0.2s ease-in forwards';
    setTimeout(() => {
        removeNotificationFromStack(celebrationDiv);
        celebrationDiv.remove();
    }, 200);
}, popupDuration * 1000);
        
           // Show confetti
           if (state.confettiPlayer) {
               showCelebration();
           }
           


           // Highlight pattern
           highlightWinningPattern(type);
           
           // Update buttons
           updateClaimButtons();
       }
// Change theme function
function changeTheme(theme) {
    const ticketContainer = document.getElementById('ticketContainer');
    const themeButtons = document.querySelectorAll('.theme-btn');
    
    // Update active button
    themeButtons.forEach(btn => {
        btn.classList.remove('active');
        if (btn.textContent.toLowerCase() === theme) {
            btn.classList.add('active');
        }
    });
    
    // Remove all theme classes
// Remove all theme classes
ticketContainer.classList.remove('theme-classic', 'theme-neon', 'theme-ocean', 'theme-vibrant', 'theme-sky', 'theme-kids', 'theme-stargazer', 'theme-quantum', 'theme-jungle', 'jungle-growing', 'jungle-full');
    
    // Add new theme class if not default
    if (theme !== 'default') {
        ticketContainer.classList.add(`theme-${theme}`);
    }
    
    // If changing to vibrant theme, add random colors to marked cells
    if (theme === 'vibrant') {
        const markedCells = ticketContainer.querySelectorAll('.ticket-cell.marked');
        markedCells.forEach(cell => {
            // Remove any existing color classes
            for (let i = 1; i <= 8; i++) {
                cell.classList.remove(`color-${i}`);
            }
            // Add a random color class
            const randomColor = Math.floor(Math.random() * 8) + 1;
            cell.classList.add(`color-${randomColor}`);
});
    
    } 

else {
        // Remove color classes when switching away from vibrant
        const allCells = ticketContainer.querySelectorAll('.ticket-cell');
        allCells.forEach(cell => {
            for (let i = 1; i <= 8; i++) {
                cell.classList.remove(`color-${i}`);
            }
        });
    }
    
    // If changing to stargazer theme, add cosmic elements
    if (theme === 'stargazer') {
        // Add shooting stars
        for (let i = 0; i < 3; i++) {
            const star = document.createElement('div');
            star.className = 'shooting-star';
            star.style.left = Math.random() * 100 + '%';
            star.style.animationDelay = i * 4 + 's';
            star.style.animationDuration = (3 + Math.random() * 2) + 's';
            ticketContainer.appendChild(star);
        }
        
        // Add planets
        const planet1 = document.createElement('div');
        planet1.className = 'planet planet-1';
        ticketContainer.appendChild(planet1);
        
        const planet2 = document.createElement('div');
        planet2.className = 'planet planet-2';
        ticketContainer.appendChild(planet2);
        
        const planet3 = document.createElement('div');
        planet3.className = 'planet planet-3';
        ticketContainer.appendChild(planet3);
        
        // Add aurora
        const aurora = document.createElement('div');
        aurora.className = 'aurora';
        ticketContainer.appendChild(aurora);
    } else {
        // Remove stargazer elements when switching away
        ticketContainer.querySelectorAll('.shooting-star, .planet, .aurora').forEach(el => el.remove());
    }
if (theme === 'quantum') {
    // Add floating quantum particles
    for (let i = 0; i < 15; i++) {
        const particle = document.createElement('div');
        particle.className = 'quantum-particle';
        particle.style.left = Math.random() * 100 + '%';
        particle.style.animationDelay = Math.random() * 10 + 's';
        particle.style.animationDuration = (10 + Math.random() * 10) + 's';
        ticketContainer.appendChild(particle);
    }
    
    // Add glitch layers
    const glitch1 = document.createElement('div');
    glitch1.className = 'glitch-layer';
    glitch1.style.pointerEvents = 'none'; // Ensure it doesn't block clicks
    ticketContainer.appendChild(glitch1);
}
        
        
// Handle jungle theme separately
    if (theme === 'jungle') {
        // Add foliage base
        const foliage = document.createElement('div');
        foliage.className = 'jungle-foliage';
        ticketContainer.appendChild(foliage);
        
        // Initialize jungle progress counter
        window.jungleProgress = 0;
        ticketContainer.classList.remove('jungle-growing', 'jungle-full');
    } else {// Remove ALL jungle elements when switching away from jungle
    ticketContainer.querySelectorAll('.jungle-creature, .jungle-bird, .jungle-butterfly, .jungle-foliage, .jungle-special-element').forEach(el => el.remove());
    window.jungleProgress = 0;
}
}  

       // Toggle mark with automatic win check
       function toggleMarkWithCheck(num, cell, phone) {
           // Check for rage clicking
           if (window.rageClickEnabled && checkRageClick(phone)) {
               return; // Prevent marking if rage clicking detected
           }
           
           if (!window.sessionMarked) {
               window.sessionMarked = [];
           }
           
           // Check if vibrant theme is active
           const ticketContainer = document.getElementById('ticketContainer');
           const isVibrantTheme = ticketContainer && ticketContainer.classList.contains('theme-vibrant');
           
           if (window.sessionMarked.includes(num)) {
               // Unmark
               window.sessionMarked = window.sessionMarked.filter(n => n !== num);
               cell.classList.remove('marked');
               
               // Remove any color classes
               if (isVibrantTheme) {
                   for (let i = 1; i <= 8; i++) {
                       cell.classList.remove(`color-${i}`);
                   }
               }
           } else {
               // Mark
               window.sessionMarked.push(num);
               cell.classList.add('marked');
               
               // Add random color class for vibrant theme
               if (isVibrantTheme) {
                   // Remove any existing color classes first
                   for (let i = 1; i <= 8; i++) {
                       cell.classList.remove(`color-${i}`);
                   }
                   // Add a random color class
                   const randomColor = Math.floor(Math.random() * 8) + 1;
                   cell.classList.add(`color-${randomColor}`);
               }
// Check if jungle theme is active
        const isJungleTheme = ticketContainer && ticketContainer.classList.contains('theme-jungle');
        if (isJungleTheme) {
            addJungleCreature();
        }
               
               // Vibrate on mark - try different patterns
               if ('vibrate' in navigator) {
                   try {
                       navigator.vibrate(50); // 50ms vibration
                   } catch (e) {
                       console.log('Vibration not supported');
                   }
               }
               
               // Check for automatic wins after marking (not on refresh)
               const isSameSession = window.cachedSessionId === window.currentSessionKey;
               if (!isSameSession && window.predeterminedSequence && window.predeterminedWinners) {
                   checkAutomaticWinsForPlayer();
               }
           }
           
           // Save to cache
           saveTicketCache(window.currentPhone, window.sessionMarked);
           
           // Update UI based on mode
           if (window.sequenceMode === 'manual') {
               updateClaimButtons();
           } else {
               updateProgress();
           }
       }
// Add jungle creatures progressively
    function addJungleCreature() {
        const ticketContainer = document.getElementById('ticketContainer');
        if (!ticketContainer || !ticketContainer.classList.contains('theme-jungle')) return;
        
        // Increment progress
        window.jungleProgress = (window.jungleProgress || 0) + 1;
        
        // Arrays of creatures and elements
        const creatures = [
            { emoji: '🦋', class: 'jungle-butterfly', weight: 3 },
            { emoji: '🐦', class: 'jungle-bird', weight: 2 },
            { emoji: '🦜', class: 'jungle-bird', weight: 1 },
            { emoji: '🐒', class: 'jungle-creature', weight: 1 },
            { emoji: '🦎', class: 'jungle-creature', weight: 2 },
            { emoji: '🐸', class: 'jungle-creature', weight: 2 },
            { emoji: '🌺', class: 'jungle-creature', weight: 3 },
            { emoji: '🌸', class: 'jungle-creature', weight: 3 },
            { emoji: '🌼', class: 'jungle-creature', weight: 3 },
            { emoji: '🌿', class: 'jungle-creature', weight: 4 },
            { emoji: '🌱', class: 'jungle-creature', weight: 4 },
            { emoji: '🍃', class: 'jungle-creature', weight: 4 },
            { emoji: '🌳', class: 'jungle-creature', weight: 1 },
            { emoji: '🌴', class: 'jungle-creature', weight: 1 },
            { emoji: '🦋', class: 'jungle-butterfly', weight: 2 },
            { emoji: '🐝', class: 'jungle-butterfly', weight: 2 },
            { emoji: '🐞', class: 'jungle-creature', weight: 3 },
            { emoji: '🦗', class: 'jungle-creature', weight: 3 },
            { emoji: '🕷️', class: 'jungle-creature', weight: 1 },
            { emoji: '🐛', class: 'jungle-creature', weight: 2 }
        ];
        
        // Create weighted array
        const weightedCreatures = [];
        creatures.forEach(creature => {
            for (let i = 0; i < creature.weight; i++) {
                weightedCreatures.push(creature);
            }
        });
        
        // Select random creature
        const creature = weightedCreatures[Math.floor(Math.random() * weightedCreatures.length)];
        
        // Create creature element
        const creatureEl = document.createElement('div');
        creatureEl.className = creature.class;
        creatureEl.textContent = creature.emoji;
        
        // Random position
        const positions = [
            { top: Math.random() * 20 - 30 + 'px', left: Math.random() * 100 + '%' },
            { bottom: Math.random() * 20 - 30 + 'px', left: Math.random() * 100 + '%' },
            { top: Math.random() * 100 + '%', left: '-30px' },
            { top: Math.random() * 100 + '%', right: '-30px' }
        ];
        
        const pos = positions[Math.floor(Math.random() * positions.length)];
        Object.assign(creatureEl.style, pos);
        
        // Different sizes
        const sizes = ['1.5rem', '2rem', '2.5rem', '3rem'];
        creatureEl.style.fontSize = sizes[Math.floor(Math.random() * sizes.length)];
        
        // Add to container
        ticketContainer.appendChild(creatureEl);
        
        // Update background based on progress
        if (window.jungleProgress >= 5 && window.jungleProgress < 10) {
            ticketContainer.classList.add('jungle-growing');
        } else if (window.jungleProgress >= 10) {
            ticketContainer.classList.remove('jungle-growing');
            ticketContainer.classList.add('jungle-full');
            
            // Add special effects for full jungle
            if (window.jungleProgress === 10) {
                // Add rainbow
                const rainbow = document.createElement('div');
                rainbow.className = 'jungle-special-element'; // Add this class
                rainbow.style.cssText = `
                    position: absolute;
                    top: -50px;
                    right: 20px;
                    font-size: 4rem;
                    animation: fadeIn 2s ease;
                `;
                rainbow.textContent = '🌈';
                ticketContainer.appendChild(rainbow);
            }
        }
        
        // Special creatures at certain milestones
        if (window.jungleProgress === 7) {
            // Add a tiger
            const tiger = document.createElement('div');
            tiger.className = 'jungle-creature';
            tiger.style.cssText = 'bottom: 10px; right: 10px; font-size: 3rem;';
            tiger.textContent = '🐅';
            ticketContainer.appendChild(tiger);
        } else if (window.jungleProgress === 12) {
            // Add an elephant
            const elephant = document.createElement('div');
            elephant.className = 'jungle-creature';
            elephant.style.cssText = 'bottom: 10px; left: 10px; font-size: 3.5rem;';
            elephant.textContent = '🐘';
            ticketContainer.appendChild(elephant);
        } else if (window.jungleProgress === 15) {
            // Add sun
            const sun = document.createElement('div');
sun.className = 'jungle-special-element'; // Add this class
            sun.style.cssText = `
                position: absolute;
                top: -40px;
                left: 30px;
                font-size: 3rem;
                animation: rotate 20s linear infinite;
            `;
            sun.textContent = '☀️';
            ticketContainer.appendChild(sun);
        }
    }

       // Check automatic wins for player
       function checkAutomaticWinsForPlayer() {
           const marked = window.sessionMarked || [];
           const ticket = window.currentTicket;
           const playerName = window.playerName || document.getElementById('playerName').textContent;
           const currentPhone = window.currentPhone;
           
           // Get existing claims
           const claimsKey = `player_claims_${window.currentSessionKey || currentPhone}`;
           const playerClaims = JSON.parse(sessionStorage.getItem(claimsKey) || '{}');
           
           // Track house games for special handling
           let houseLateGames = [];
           let houseWonGames = [];
           
           // Check each game type
           window.selectedGames.forEach(type => {
               // Skip if already claimed
               if (playerClaims[type]) return;
               
               // Check if pattern is complete
               if (checkWinCondition(ticket, marked, type)) {
                   // Check if this player is the predetermined winner
                   const predeterminedWinner = window.predeterminedWinners[type];
                   
                   // Special handling for house2
                   if (type === 'house2') {
                       const house1Winner = window.predeterminedWinners['house1'];
                       if (house1Winner && house1Winner.winner === playerName) {
                           // This player won house1, so they can't win house2
                           const actualWinner = predeterminedWinner ? predeterminedWinner.winner : 'Unknown';
                           
                           playerClaims[type] = {
                               status: 'late',
                               amount: 0,
                               timestamp: new Date().toISOString(),
                               automatic: true,
                               winnerName: actualWinner
                           };
                           
                           sessionStorage.setItem(claimsKey, JSON.stringify(playerClaims));
                           
                           // Track for later handling
                           houseLateGames.push({ type, actualWinner });
                           
                           // Update progress display
                           updateProgress();
                           return;
                       }
                   }
                   
if (predeterminedWinner && 
    (predeterminedWinner.winner === playerName || 
     (predeterminedWinner.allWinners && predeterminedWinner.allWinners.includes(playerName)))) {
    // Automatic win
    // Check if there are other winners on the same number
    let splitCount = 1;
    let allWinners = [];
    if (predeterminedWinner.allWinners && predeterminedWinner.allWinners.length > 0) {
        splitCount = predeterminedWinner.allWinners.length;
        allWinners = predeterminedWinner.allWinners;
    } else {
        // Fallback to single winner
        splitCount = 1;
        allWinners = [predeterminedWinner.winner];
    }

const originalPrize = window.gamePrizes[type] || 0;
const splitPrize = Math.round(originalPrize / splitCount);

// Automatic win
playerClaims[type] = {
    status: 'won',
    amount: splitPrize,
    originalAmount: originalPrize,
    splitCount: splitCount,
    allWinners: allWinners,  // Add this line
    timestamp: new Date().toISOString(),
    automatic: true
};
                       
                       sessionStorage.setItem(claimsKey, JSON.stringify(playerClaims));
                       
                       // Track house wins
                       if (type === 'fullHouse' || type === 'house1' || type === 'house2') {
                           houseWonGames.push(type);
                       } else {
// Show celebration for non-house games immediately
let popupDuration = 5;
// First check if we have duration from URL (player mode)
if (window.playerPopupDuration) {
    popupDuration = window.playerPopupDuration;
} else {
    // Fallback to localStorage for admin or if not set
    const savedGame = localStorage.getItem('housieGame');
    if (savedGame) {
        const state = JSON.parse(savedGame);
        popupDuration = state.playerPopupDuration || state.glowDuration || 5;
    }
}
const celebrationDiv = document.createElement('div');
celebrationDiv.className = `game-notification winner-celebration ${getNotificationThemeClass()}`;
let celebrationText = getGameTypeName(type);
if (splitCount > 1) {
    celebrationText += ` (Split ${splitCount} ways)`;
}
celebrationDiv.innerHTML = `
    <span class="icon">🎉</span>
    <span class="text">${celebrationText}</span>
    <span class="amount">₹${splitPrize}</span>
`;

document.body.appendChild(celebrationDiv);

// Add to notification stack
addNotificationToStack(celebrationDiv);

// Remove after duration
setTimeout(() => {
    celebrationDiv.style.animation = 'slideDown 0.2s ease-in forwards';
    setTimeout(() => {
        removeNotificationFromStack(celebrationDiv);
        celebrationDiv.remove();
    }, 200);
}, popupDuration * 1000);
                           // Show confettio
                           showCelebration();
                           
                           // Highlight pattern
                           highlightWinningPattern(type);
                       }
                       
                       // Update progress display
                       updateProgress();
                   } else {
                       // Not the winner
                     // Not the winner
let actualWinner = 'Unknown';
let allWinnersForDisplay = [];

// Try to get all winner names
if (predeterminedWinner) {
    if (predeterminedWinner.allWinners && predeterminedWinner.allWinners.length > 0) {
        allWinnersForDisplay = predeterminedWinner.allWinners;
        actualWinner = allWinnersForDisplay.join(' & ');
    } else if (predeterminedWinner.winner) {
        actualWinner = predeterminedWinner.winner;
        allWinnersForDisplay = [predeterminedWinner.winner];
    }
}else {
                           // Check if someone else already won in traditional mode
                           const savedGame = localStorage.getItem('housieGame');
                           if (savedGame) {
                               const state = JSON.parse(savedGame);
                               if (state.winners && state.winners[type]) {
                                   const winnersData = state.winners[type];
                                   if (Array.isArray(winnersData) && winnersData.length > 0) {
                                       actualWinner = winnersData[0];
                                   } else if (winnersData.list && winnersData.list.length > 0) {
                                       actualWinner = winnersData.list[0];
                                   }
                               }
                           }
                       }
                       
                       playerClaims[type] = {
                           status: 'late',
                           amount: 0,
                           timestamp: new Date().toISOString(),
                           automatic: true,
                           winnerName: actualWinner,
 allWinners: allWinnersForDisplay  // Add this line
                       };
                       
                       sessionStorage.setItem(claimsKey, JSON.stringify(playerClaims));
                       
                   // Skip showing "too late" for house games entirely
if (type !== 'fullHouse' && type !== 'house1' && type !== 'house2') {
    // Show too late for non-house games only
    showTooLateNotification(getGameTypeName(type), actualWinner);
}
                       
                       // Update progress display
                       updateProgress();
                   }
               }
           });
           
           // Handle house game popups
           if (houseWonGames.length > 0) {
               // Show celebration for each house game individually
               houseWonGames.forEach((houseGame) => {
                   let popupDuration = 5;
// First check if we have duration from URL (player mode)
if (window.playerPopupDuration) {
    popupDuration = window.playerPopupDuration;
} else {
    // Fallback to localStorage for admin or if not set
    const savedGame = localStorage.getItem('housieGame');
    if (savedGame) {
        const state = JSON.parse(savedGame);
        popupDuration = state.playerPopupDuration || state.glowDuration || 5;
    }
}
                   
const celebrationDiv = document.createElement('div');
celebrationDiv.className = `game-notification winner-celebration ${getNotificationThemeClass()}`;
                   celebrationDiv.innerHTML = `
                       <span class="icon">🎉</span>
                       <span class="text">${getGameTypeName(houseGame)}</span>
                       <span class="amount">₹${window.gamePrizes[houseGame]}</span>
                   `;
                   
                   document.body.appendChild(celebrationDiv);
                   
                   // Add to notification stack
                   addNotificationToStack(celebrationDiv);
                   
                   // Remove after duration
                   setTimeout(() => {
                       celebrationDiv.style.animation = 'slideDown 0.2s ease-in forwards';
                       setTimeout(() => {
                           removeNotificationFromStack(celebrationDiv);
                           celebrationDiv.remove();
                       }, 200);
                   }, popupDuration * 1000);
               });
               
               // Show confetti
               showCelebration();
               
               // Highlight pattern for the first house game
               highlightWinningPattern(houseWonGames[0]);
           }
           
      // Handle house late games - REMOVED to not show house lost notifications
// if (houseLateGames.length > 0) {
//     houseLateGames.forEach(({ type, actualWinner }) => {
//         showTooLateNotification(getGameTypeName(type), actualWinner);
//     });
// }
       }

function showTooLateNotification(gameName, winnerName) {
    const savedGame = localStorage.getItem('housieGame');
    let popupDuration = 5;
    if (savedGame) {
        const state = JSON.parse(savedGame);
        popupDuration = state.playerPopupDuration || state.glowDuration || 5;
    }
    
    const notification = document.createElement('div');
    notification.className = 'game-notification too-late-notification';
    notification.innerHTML = `
        <span class="icon">❌</span>
        <span class="text">${gameName} • Won by ${winnerName}</span>
    `;
    
   document.body.appendChild(notification);

// Add to notification stack
addNotificationToStack(notification);

// Remove after duration
setTimeout(() => {
    notification.style.animation = 'slideDown 0.2s ease-in forwards';
    setTimeout(() => {
        removeNotificationFromStack(notification);
        notification.remove();
    }, 200);
}, popupDuration * 1000);
}

       // Update progress display
       function updateProgress() {
           const progressSection = document.getElementById('progressSection');
           if (!progressSection || !window.selectedGames || !window.currentTicket) return;
           
           progressSection.innerHTML = '<h4 style="margin-bottom: 1rem; font-size: 1rem; font-weight: 600;">Your Progress:</h4>';
           
           const marked = window.sessionMarked || [];
           const ticket = window.currentTicket;
           const allNumbers = ticket.flat().filter(n => n > 0);
           
           // Use session-specific claims key
           const claimsKey = `player_claims_${window.currentSessionKey || window.currentPhone}`;
           const playerClaims = JSON.parse(sessionStorage.getItem(claimsKey) || '{}');
           
           let totalWinnings = 0;
           
           window.selectedGames.forEach(type => {
               const progressItem = document.createElement('div');
               progressItem.className = 'progress-item';
               progressItem.style.marginBottom = '1.5rem';
               
               let required = 0;
               let completed = 0;
               
               // Calculate progress for each game type
               switch (type) {
                   case 'firstFive':
                       required = 5;
                       completed = Math.min(marked.filter(n => allNumbers.includes(n)).length, 5);
                       break;
                       
                   case 'lucky7':
                       required = 7;
                       completed = Math.min(marked.filter(n => allNumbers.includes(n)).length, 7);
                       break;
                       
                   case 'topLine':
                       const topLineNumbers = ticket[0].filter(n => n > 0);
                       required = topLineNumbers.length;
                       completed = topLineNumbers.filter(n => marked.includes(n)).length;
                       break;
                       
                   case 'middleLine':
                       const middleLineNumbers = ticket[1].filter(n => n > 0);
                       required = middleLineNumbers.length;
                       completed = middleLineNumbers.filter(n => marked.includes(n)).length;
                       break;
                       
                   case 'bottomLine':
                       const bottomLineNumbers = ticket[2].filter(n => n > 0);
                       required = bottomLineNumbers.length;
                       completed = bottomLineNumbers.filter(n => marked.includes(n)).length;
                       break;
                       
                   case 'corners':
                       required = 4;
                       const corners = [];
                       for (let i = 0; i < 9; i++) {
                           if (ticket[0][i] > 0) { corners.push(ticket[0][i]); break; }
                       }
                       for (let i = 8; i >= 0; i--) {
                           if (ticket[0][i] > 0 && !corners.includes(ticket[0][i])) { 
                               corners.push(ticket[0][i]); break; 
                           }
                       }
                       for (let i = 0; i < 9; i++) {
                           if (ticket[2][i] > 0 && !corners.includes(ticket[2][i])) { 
                               corners.push(ticket[2][i]); break; 
                           }
                       }
                       for (let i = 8; i >= 0; i--) {
                           if (ticket[2][i] > 0 && !corners.includes(ticket[2][i])) { 
                               corners.push(ticket[2][i]); break; 
                           }
                       }
                       completed = corners.filter(n => marked.includes(n)).length;
                       break;
                       
                   case 'pyramid':
                       // Get numbers from each row
                       const topRowNums = ticket[0].filter(n => n > 0);
                       const middleRowNums = ticket[1].filter(n => n > 0);
                       const bottomRowNums = ticket[2].filter(n => n > 0);
                       
                       if (topRowNums.length === 5 && middleRowNums.length === 5 && bottomRowNums.length === 5) {
                           // Top row: middle number (index 2 of 5 numbers)
                           const topMiddle = topRowNums[2];
                           // Middle row: middle 3 numbers (indices 1,2,3 of 5 numbers)
                           const middleThree = [middleRowNums[1], middleRowNums[2], middleRowNums[3]];
                           // Bottom row: all 5 numbers
                           
                           const pyramidNumbers = [topMiddle, ...middleThree, ...bottomRowNums];
                           required = pyramidNumbers.length;
                           completed = pyramidNumbers.filter(n => marked.includes(n)).length;
                       } else {
                           required = 0;
                           completed = 0;
                       }
                       break;
                       
                   case 'railwayTrack':
                       const topLineTrack = ticket[0].filter(n => n > 0);
                       const bottomLineTrack = ticket[2].filter(n => n > 0);
                       const trackNumbers = [...topLineTrack, ...bottomLineTrack];
                       required = trackNumbers.length;
                       completed = trackNumbers.filter(n => marked.includes(n)).length;
                       break;
                       
                   case 'fullHouse':
                   case 'house1':
                   case 'house2':
                       required = allNumbers.length;
                       completed = allNumbers.filter(n => marked.includes(n)).length;
                       break;
                       
                   case 'firstTwoLines':
                       const firstTwoLinesNums = [...ticket[0], ...ticket[1]].filter(n => n > 0);
                       required = firstTwoLinesNums.length;
                       completed = firstTwoLinesNums.filter(n => marked.includes(n)).length;
                       break;
                       
                   case 'lastTwoLines':
                       const lastTwoLinesNums = [...ticket[1], ...ticket[2]].filter(n => n > 0);
                       required = lastTwoLinesNums.length;
                       completed = lastTwoLinesNums.filter(n => marked.includes(n)).length;
                       break;
                       
                   case 'centerColumn':
                       const centerCol = [ticket[0][4], ticket[1][4], ticket[2][4]].filter(n => n > 0);
                       required = centerCol.length;
                       completed = centerCol.filter(n => marked.includes(n)).length;
                       break;
                       
                   case 'bullsEye':
                       // Get all numbers from middle row
                       const middleRowNumbers = ticket[1].filter(n => n > 0);
                       if (middleRowNumbers.length === 5) {
                           // Middle number is at index 2 (3rd position out of 5)
                           const middleNumber = middleRowNumbers[2];
                           required = 1;
                           completed = (middleNumber > 0 && marked.includes(middleNumber)) ? 1 : 0;
                       } else {
                           required = 0;
                           completed = 0;
                       }
                       break;
                       
                   case 'breakfast':
                       // First 3 columns
                       const breakfastNumbers = [];
                       for (let col = 0; col < 3; col++) {
                           for (let row = 0; row < 3; row++) {
                               if (ticket[row][col] > 0) {
                                   breakfastNumbers.push(ticket[row][col]);
                               }
                           }
                       }
                       required = breakfastNumbers.length;
                       completed = breakfastNumbers.filter(n => marked.includes(n)).length;
                       break;
                       
                   case 'lunch':
                       // Middle 3 columns (3,4,5)
                       const lunchNumbers = [];
                       for (let col = 3; col < 6; col++) {
                           for (let row = 0; row < 3; row++) {
                               if (ticket[row][col] > 0) {
                                   lunchNumbers.push(ticket[row][col]);
                               }
                           }
                       }
                       required = lunchNumbers.length;
                       completed = lunchNumbers.filter(n => marked.includes(n)).length;
                       break;
                       
                   case 'dinner':
                       // Last 3 columns
                       const dinnerNumbers = [];
                       for (let col = 6; col < 9; col++) {
                           for (let row = 0; row < 3; row++) {
                               if (ticket[row][col] > 0) {
                                   dinnerNumbers.push(ticket[row][col]);
                               }
                           }
                       }
                       required = dinnerNumbers.length;
                       completed = dinnerNumbers.filter(n => marked.includes(n)).length;
                       break;
               }
               
               const percentage = required > 0 ? (completed / required) * 100 : 0;
               const prize = window.gamePrizes[type] || 0;
               
               // Determine color based on percentage
               let colorClass = 'low';
               if (percentage >= 80) colorClass = 'high';
               else if (percentage >= 50) colorClass = 'medium';
               
               // Don't show predetermined winner info until they've won
               let predeterminedWinnerInfo = '';
               
               let statusDisplay = '';
               const playerClaim = playerClaims[type];
               
               if (playerClaim) {
                   // Already processed
if (playerClaim.status === 'won') {
    let winText = `✓ You Won! ₹${playerClaim.amount}`;
    if (playerClaim.splitCount && playerClaim.splitCount > 1) {
        winText += ` <span style="font-size: 0.75rem; opacity: 0.8;">(₹${playerClaim.originalAmount} ÷ ${playerClaim.splitCount} = ₹${playerClaim.amount} each)</span>`;
        // Show who you won with
        if (playerClaim.allWinners && playerClaim.allWinners.length > 1) {
            const otherWinners = playerClaim.allWinners.filter(w => w !== window.playerName);
            if (otherWinners.length > 0) {
                winText += `<br><span style="font-size: 0.75rem; opacity: 0.8;">Won with: ${otherWinners.join(', ')}</span>`;
            }
        }
    }
    statusDisplay = `<div style="color: #10b981; font-weight: 600; margin-top: 0.75rem;">${winText}</div>`;
    totalWinnings += playerClaim.amount;
}else {
    // For house games, don't show "lost" status - just hide it
    if (type === 'fullHouse' || type === 'house1' || type === 'house2') {
        // Don't show any status for house games that were "lost"
        statusDisplay = '';
    } else {
        // For non-house games, show "Too Late!" message
statusDisplay = `<div style="color: #ef4444; font-weight: 600; margin-top: 0.75rem;">
    ✗ Too Late!
    <div style="font-size: 0.875rem; font-weight: 500; margin-top: 0.5rem; padding: 0.5rem 1rem; background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%); border: 1px solid #fca5a5; border-radius: 9999px; display: inline-block; color: #991b1b;">
        🏆 Won by: <strong style="color: #7f1d1d;">${playerClaim.winnerName || 'Unknown'}</strong>
    </div>
</div>`;
    }
}
               }
               
               progressItem.innerHTML = `
                   <div class="progress-label">
                       <span>${getGameTypeName(type)} (Prize: ₹${prize}) <span class="info-icon" onclick="showGameInfo('${type}')">i</span>${predeterminedWinnerInfo}</span>
                       <span>${completed}/${required}</span>
                   </div>
                   <div class="progress-bar">
                       <div class="progress-fill ${colorClass}" style="width: ${percentage}%"></div>
                   </div>
                   ${statusDisplay}
               `;
               
               progressSection.appendChild(progressItem);
           });
           
           // Show total winnings
           if (totalWinnings > 0 || Object.keys(playerClaims).length > 0) {
               const totalDiv = document.createElement('div');
               totalDiv.style.cssText = 'margin-top: 1.5rem; padding: 1rem; background: linear-gradient(to bottom right, #f0fdf4, #dcfce7); border-radius: 0.75rem; text-align: center; border: 1px solid #bbf7d0;';
               totalDiv.innerHTML = `
                   <h3 style="color: #059669; margin: 0; font-size: 1.25rem;">Total Winnings: ₹${totalWinnings}</h3>
               `;
               progressSection.appendChild(totalDiv);
           }
       }

       // Check win condition
       function checkWinCondition(ticket, marked, type) {
           const allNumbers = ticket.flat().filter(n => n > 0);
           
           switch (type) {
               case 'firstFive':
                   return marked.filter(n => allNumbers.includes(n)).length >= 5;
               
               case 'lucky7':
                   return marked.filter(n => allNumbers.includes(n)).length >= 7;
               
               case 'topLine':
                   return ticket[0].filter(n => n > 0).every(n => marked.includes(n));
               
               case 'middleLine':
                   return ticket[1].filter(n => n > 0).every(n => marked.includes(n));
               
               case 'bottomLine':
                   return ticket[2].filter(n => n > 0).every(n => marked.includes(n));
               
               case 'corners':
                   const corners = [];
                   // Find actual corners
                   for (let i = 0; i < 9; i++) {
                       if (ticket[0][i] > 0) { corners.push(ticket[0][i]); break; }
                   }
                   for (let i = 8; i >= 0; i--) {
                       if (ticket[0][i] > 0 && !corners.includes(ticket[0][i])) { 
                           corners.push(ticket[0][i]); break; 
                       }
                   }
                   for (let i = 0; i < 9; i++) {
                       if (ticket[2][i] > 0 && !corners.includes(ticket[2][i])) { 
                           corners.push(ticket[2][i]); break; 
                       }
                   }
                   for (let i = 8; i >= 0; i--) {
                       if (ticket[2][i] > 0 && !corners.includes(ticket[2][i])) { 
                           corners.push(ticket[2][i]); break; 
                       }
                   }
                   return corners.length === 4 && corners.every(n => marked.includes(n));
               
               case 'pyramid':
                   // Get numbers from each row
                   const topRowNums = ticket[0].filter(n => n > 0);
                   const middleRowNums = ticket[1].filter(n => n > 0);
                   const bottomRowNums = ticket[2].filter(n => n > 0);
                   
                   if (topRowNums.length === 5 && middleRowNums.length === 5 && bottomRowNums.length === 5) {
                       // Top row: middle number (index 2 of 5 numbers)
                       const topMiddle = topRowNums[2];
                       // Middle row: middle 3 numbers (indices 1,2,3 of 5 numbers)
                       const middleThree = [middleRowNums[1], middleRowNums[2], middleRowNums[3]];
                       // Bottom row: all 5 numbers
                       
                       const pyramidNumbers = [topMiddle, ...middleThree, ...bottomRowNums];
                       return pyramidNumbers.every(n => marked.includes(n));
                   }
                   return false;
               
               case 'railwayTrack':
                   // Both top and bottom lines must be complete
                   const topLine = ticket[0].filter(n => n > 0);
                   const bottomLine = ticket[2].filter(n => n > 0);
                   return topLine.every(n => marked.includes(n)) && bottomLine.every(n => marked.includes(n));
               
               case 'fullHouse':
               case 'house1':
               case 'house2':
                   // All three are full house (all numbers)
                   return allNumbers.every(n => marked.includes(n));
                   
               case 'firstTwoLines':
                   // All numbers in first two lines must be marked
                   const firstTwoLines = [...ticket[0], ...ticket[1]].filter(n => n > 0);
                   return firstTwoLines.every(n => marked.includes(n));
               
               case 'lastTwoLines':
                   // All numbers in last two lines must be marked
                   const lastTwoLines = [...ticket[1], ...ticket[2]].filter(n => n > 0);
                   return lastTwoLines.every(n => marked.includes(n));
               
               case 'centerColumn':
                   const centerCol = [ticket[0][4], ticket[1][4], ticket[2][4]].filter(n => n > 0);
                   return centerCol.length > 0 && centerCol.every(n => marked.includes(n));
               
               case 'bullsEye':
                   // Get all numbers from middle row
                   const middleRowNumbers = ticket[1].filter(n => n > 0);
                   // Check if we have exactly 5 numbers
                   if (middleRowNumbers.length !== 5) {
                       return false;
                   }
                   // Middle number is at index 2 (3rd position out of 5)
                   const middleNumber = middleRowNumbers[2];
                   return middleNumber > 0 && marked.includes(middleNumber);
                   
               case 'breakfast':
                   // All numbers in first 3 columns
                   const breakfastNumbers = [];
                   for (let col = 0; col < 3; col++) {
                       for (let row = 0; row < 3; row++) {
                           if (ticket[row][col] > 0) {
                               breakfastNumbers.push(ticket[row][col]);
                           }
                       }
                   }
                   return breakfastNumbers.length > 0 && breakfastNumbers.every(n => marked.includes(n));
                   
               case 'lunch':
                   // All numbers in middle 3 columns (3,4,5)
                   const lunchNumbers = [];
                   for (let col = 3; col < 6; col++) {
                       for (let row = 0; row < 3; row++) {
                           if (ticket[row][col] > 0) {
                               lunchNumbers.push(ticket[row][col]);
                           }
                       }
                   }
                   return lunchNumbers.length > 0 && lunchNumbers.every(n => marked.includes(n));
                   
               case 'dinner':
                   // All numbers in last 3 columns
                   const dinnerNumbers = [];
                   for (let col = 6; col < 9; col++) {
                       for (let row = 0; row < 3; row++) {
                           if (ticket[row][col] > 0) {
                               dinnerNumbers.push(ticket[row][col]);
                           }
                       }
                   }
                   return dinnerNumbers.length > 0 && dinnerNumbers.every(n => marked.includes(n));
               
               default:
                   return false;
           }
       }

       // Get game type name
       function getGameTypeName(type) {
           const gameType = allGameTypes.find(gt => gt.id === type);
           return gameType ? gameType.name : type;
       }

       // Show winners
       function showWinners() {
           const modal = document.getElementById('winnersModal');
           const winnersListDiv = document.getElementById('winnersList');
           const summaryDiv = document.getElementById('winnersSummary');
           const summaryList = document.getElementById('winnersSummaryList');

           winnersListDiv.innerHTML = '';
           summaryList.innerHTML = '';
           summaryDiv.style.display = 'none';

           // Collect player winnings based on winners list
           const playerWinnings = {}; // playerName -> total

           // Render game-wise winners
           gameState.gameTypes.forEach(type => {
            const prize = gameState.prizes[type] || 0;
               const winnersData = gameState.winners[type] || { list: [], winningNumbers: {} };
               const winnersList = Array.isArray(winnersData) ? winnersData : (winnersData.list || []);
               
               const div = document.createElement('div');
               div.className = 'winner-item';
               
               if (winnersList.length === 0) {
                   div.innerHTML = `<span>${getGameTypeName(type)} (₹${prize})</span><span class="winner-badge">---</span>`;
               } else {
                   // Group winners by the number they won on
                   const winnerGroups = {};
                   let hasWinningNumbers = false;
                   
                   if (winnersData.winningNumbers && !Array.isArray(winnersData)) {
                       hasWinningNumbers = true;
                       // Group all winners by their winning number
                       for (const [num, winnersOnNum] of Object.entries(winnersData.winningNumbers)) {
                           if (winnersOnNum && winnersOnNum.length > 0) {
                               winnersOnNum.forEach(winner => {
                                   if (!winnerGroups[num]) winnerGroups[num] = [];
                                   if (!winnerGroups[num].includes(winner)) {
                                       winnerGroups[num].push(winner);
                                   }
                               });
                           }
                       }
                   }
                   
                   // If we have winning number data, calculate prizes based on groups
                   if (hasWinningNumbers && Object.keys(winnerGroups).length > 0) {
                       let displayParts = [];
                       let maxGroupSize = 1;
                       
                       for (const [num, winnersOnNum] of Object.entries(winnerGroups)) {
                           if (winnersOnNum.length > maxGroupSize) {
                               maxGroupSize = winnersOnNum.length;
                           }
                           
                           if (winnersOnNum.length > 1) {
                               // Multiple winners on same number - they split the prize
                               const splitPrize = Math.round(prize / winnersOnNum.length);
                               winnersOnNum.forEach(winner => {
                                   if (!playerWinnings[winner]) playerWinnings[winner] = 0;
                                   playerWinnings[winner] += splitPrize;
                               });
                           } else {
                               // Single winner on this number - gets full prize
                               const winner = winnersOnNum[0];
                               if (!playerWinnings[winner]) playerWinnings[winner] = 0;
                               playerWinnings[winner] += prize;
                           }
                       }
                       
                       // For display, if any group has multiple winners, show the split
                       if (maxGroupSize > 1) {
                           const splitPrize = Math.round(prize / maxGroupSize);
                           div.innerHTML = `<span>${getGameTypeName(type)} (₹${prize} ÷ ${maxGroupSize} = ₹${splitPrize} each)</span><span class="winner-badge">${winnersList.join(', ')} <small>(same number)</small></span>`;
                       } else {
                           // All winners won on different numbers
                           div.innerHTML = `<span>${getGameTypeName(type)} (₹${prize})</span><span class="winner-badge">${winnersList.join(', ')}</span>`;
                       }
                   } else {
                       // No winning number data - assume all get full prize
                       div.innerHTML = `<span>${getGameTypeName(type)} (₹${prize})</span><span class="winner-badge">${winnersList.join(', ')}</span>`;
                       winnersList.forEach(winner => {
                           if (!playerWinnings[winner]) playerWinnings[winner] = 0;
                           playerWinnings[winner] += prize;
                       });
                   }
               }
               
               winnersListDiv.appendChild(div);
           });

           // Render player-wise summary
           const winnersNames = Object.keys(playerWinnings);
           if (winnersNames.length > 0) {
               summaryDiv.style.display = 'block';
               winnersNames.sort((a, b) => playerWinnings[b] - playerWinnings[a]);
               winnersNames.forEach(name => {
                   const item = document.createElement('div');
                   item.className = 'winner-summary-item';
                   item.innerHTML = `<span>${name}</span><span>₹${playerWinnings[name]}</span>`;
                   summaryList.appendChild(item);
               });
               
               // Add total row
               const totalWinnings = Object.values(playerWinnings).reduce((sum, amount) => sum + amount, 0);
               const totalItem = document.createElement('div');
               totalItem.className = 'winner-summary-item';
               totalItem.style.fontWeight = '600';
               totalItem.innerHTML = `<span>Total Distributed</span><span>₹${totalWinnings}</span>`;
               summaryList.appendChild(totalItem);
           }

           modal.style.display = 'flex';
       }
       
       // Share winning summary
       function shareWinningSummary() {
           // Prepare summary data
           const summaryData = {
               kittyAmount: gameState.kittyAmount,
               gameTypes: gameState.gameTypes,
               prizes: gameState.prizes,
               winners: gameState.winners,
               players: gameState.players.map(p => ({ name: p.name, phone: p.phone }))
           };
           
           // Create WhatsApp message
           let message = `🎉 *HOUSIE GAME RESULTS* 🎉\n\n`;
           message += `Total Prize Pool: ₹${gameState.kittyAmount}\n\n`;
           message += `🏆 *Game Winners:*\n`;
           message += `━━━━━━━━━━━━━━━━\n`;
           
           const playerWinnings = {};
           
           gameState.gameTypes.forEach(type => {
               const prize = gameState.prizes[type] || 0;
               const winnersData = gameState.winners[type] || { list: [], winningNumbers: {} };
               const winnersList = Array.isArray(winnersData) ? winnersData : (winnersData.list || []);
               
               if (winnersList.length === 0) {
                   message += `${getGameTypeName(type)} (₹${prize}): No Winner\n`;
               } else {
                   // Group winners by the number they won on
                   const winnerGroups = {};
                   let hasWinningNumbers = false;
                   
                   if (winnersData.winningNumbers && !Array.isArray(winnersData)) {
                       hasWinningNumbers = true;
                       // Group all winners by their winning number
                       for (const [num, winnersOnNum] of Object.entries(winnersData.winningNumbers)) {
                           if (winnersOnNum && winnersOnNum.length > 0) {
                               winnersOnNum.forEach(winner => {
                                   if (!winnerGroups[num]) winnerGroups[num] = [];
                                   if (!winnerGroups[num].includes(winner)) {
                                       winnerGroups[num].push(winner);
                                   }
                               });
                           }
                       }
                   }
                   
                   // Calculate actual winnings
                   if (hasWinningNumbers && Object.keys(winnerGroups).length > 0) {
                       let maxGroupSize = 1;
                       let hasMultipleWinnersOnSameNumber = false;
                       
                       // First pass - find the maximum group size
                       for (const [num, winnersOnNum] of Object.entries(winnerGroups)) {
                           if (winnersOnNum.length > maxGroupSize) {
                               maxGroupSize = winnersOnNum.length;
                               hasMultipleWinnersOnSameNumber = true;
                           }
                       }
                       
                       // Second pass - calculate winnings
                       for (const [num, winnersOnNum] of Object.entries(winnerGroups)) {
                           if (winnersOnNum.length === maxGroupSize && maxGroupSize > 1) {
                               // These winners share the prize
                               const splitPrize = Math.round(prize / maxGroupSize);
                               winnersOnNum.forEach(winner => {
                                   if (!playerWinnings[winner]) playerWinnings[winner] = 0;
                                   playerWinnings[winner] += splitPrize;
                               });
                           } else {
                               // Single winner on this number - gets full prize
                               winnersOnNum.forEach(winner => {
                                   if (!playerWinnings[winner]) playerWinnings[winner] = 0;
                                   playerWinnings[winner] += prize;
                               });
                           }
                       }
                       
                       if (hasMultipleWinnersOnSameNumber) {
                           const splitPrize = Math.round(prize / maxGroupSize);
                           message += `${getGameTypeName(type)} (₹${prize} ÷ ${maxGroupSize}): ${winnersList.join(', ')} (₹${splitPrize} each - same number)\n`;
                       } else {
                           message += `${getGameTypeName(type)} (₹${prize}): ${winnersList.join(', ')}\n`;
                       }
                   } else {
                       // No winning number data
                       message += `${getGameTypeName(type)} (₹${prize}): ${winnersList.join(', ')}\n`;
                       winnersList.forEach(winner => {
                           if (!playerWinnings[winner]) playerWinnings[winner] = 0;
                           playerWinnings[winner] += prize;
                       });
                   }
               }
           });
           
           message += `\n━━━━━━━━━━━━━━━━\n`;
           message += `💰 *Player-wise Summary:*\n`;
           
           const sortedWinners = Object.keys(playerWinnings).sort((a, b) => playerWinnings[b] - playerWinnings[a]);
           sortedWinners.forEach(name => {
               message += `${name}: ₹${playerWinnings[name]}\n`;
           });
           
           const totalDistributed = Object.values(playerWinnings).reduce((sum, amount) => sum + amount, 0);
           message += `\nTotal Distributed: ₹${totalDistributed}\n`;
           
           // Create URL for web view
           const encodedSummary = encodeWinnersData(summaryData);
           const summaryUrl = `https://chopra3sahil.github.io/tembola/?winners=${encodedSummary}`;
           
           message += `\n📊 View detailed results:\n${summaryUrl}\n`;
           message += `\n🎊 Thank you for playing! 🎊`;
           
           // Create modal to show message and share options
           const shareModal = document.createElement('div');
           shareModal.className = 'modal';
           shareModal.style.display = 'flex';
           shareModal.style.zIndex = '1002';
           
           const shareContent = document.createElement('div');
           shareContent.className = 'modal-content';
           shareContent.innerHTML = '<h2>Share Winning Summary</h2>';
           
           const msgDiv = document.createElement('div');
           msgDiv.className = 'group-message-container';
           msgDiv.textContent = message;
           shareContent.appendChild(msgDiv);
           
           const shareList = document.createElement('div');
           shareList.style.marginTop = '1rem';
           
           // Add individual share buttons for each player
           gameState.players.forEach(player => {
               const shareItem = document.createElement('div');
               shareItem.style.cssText = 'margin-bottom: 0.5rem;';
               
               const shareBtn = document.createElement('button');
               shareBtn.className = 'btn btn-success';
               shareBtn.style.width = '100%';
               shareBtn.textContent = `Share to ${player.name} (${player.phone})`;
               shareBtn.onclick = () => {
                   const whatsappUrl = `https://wa.me/${player.phone}?text=${encodeURIComponent(message)}`;
                   window.open(whatsappUrl, '_blank');
               };
               
               shareItem.appendChild(shareBtn);
               shareList.appendChild(shareItem);
           });
           
           shareContent.appendChild(shareList);
           
           const btnContainer = document.createElement('div');
           btnContainer.style.display = 'flex';
           btnContainer.style.gap = '0.5rem';
           btnContainer.style.marginTop = '1rem';
           
           const copyBtn = document.createElement('button');
           copyBtn.className = 'btn btn-warning';
           copyBtn.textContent = 'Copy Message';
           copyBtn.onclick = () => {
               navigator.clipboard.writeText(message).then(() => {
                   alert('Summary copied to clipboard!');
               });
           };
           btnContainer.appendChild(copyBtn);
           
           const closeBtn = document.createElement('button');
           closeBtn.className = 'btn btn-secondary';
           closeBtn.textContent = 'Close';
           closeBtn.onclick = () => shareModal.remove();
           btnContainer.appendChild(closeBtn);
           
           shareContent.appendChild(btnContainer);
           shareModal.appendChild(shareContent);
           document.body.appendChild(shareModal);
       }
       
// Show settlement calculator
function showSettlementCalculator() {
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'flex';
    modal.style.zIndex = '1003';
    
    const content = document.createElement('div');
    content.className = 'modal-content';
    content.innerHTML = `
        <h2>Settlement Calculator</h2>
        <div class="input-group">
            <label>Ticket Price per Person (₹):</label>
            <input type="number" id="ticketPrice" min="0" value="50" style="font-size: 1.25rem; text-align: center;">
        </div>
        <button class="btn btn-success" onclick="calculateSettlement()">Calculate Settlement</button>
        <button class="btn btn-secondary" onclick="this.closest('.modal').remove()">Cancel</button>
        <div id="settlementResult" style="margin-top: 1.5rem;"></div>
    `;
    
    modal.appendChild(content);
    document.body.appendChild(modal);
}

// Calculate settlement
function calculateSettlement() {
    const ticketPrice = parseFloat(document.getElementById('ticketPrice').value) || 0;
    const resultDiv = document.getElementById('settlementResult');
    
    if (ticketPrice <= 0) {
        alert('Please enter a valid ticket price!');
        return;
    }
    
    // Calculate each player's position
    const settlements = [];
    const playerWinnings = {};
    
    // First, calculate total winnings per player
    gameState.gameTypes.forEach(type => {
        const winnersData = gameState.winners[type] || { list: [], winningNumbers: {} };
        const prize = gameState.prizes[type] || 0;
        
        if (winnersData.winningNumbers && !Array.isArray(winnersData)) {
            // Calculate split prizes based on winning numbers
            for (const [num, winnersOnNum] of Object.entries(winnersData.winningNumbers)) {
                if (winnersOnNum && winnersOnNum.length > 0) {
                    const splitPrize = Math.round(prize / winnersOnNum.length);
                    winnersOnNum.forEach(winner => {
                        if (!playerWinnings[winner]) playerWinnings[winner] = 0;
                        playerWinnings[winner] += splitPrize;
                    });
                }
            }
        } else {
            // Fallback for old format
            const winnersList = Array.isArray(winnersData) ? winnersData : (winnersData.list || []);
            if (winnersList.length > 0) {
                const splitPrize = Math.round(prize / winnersList.length);
                winnersList.forEach(winner => {
                    if (!playerWinnings[winner]) playerWinnings[winner] = 0;
                    playerWinnings[winner] += splitPrize;
                });
            }
        }
    });
    
    // Calculate net position for each player
    gameState.players.forEach(player => {
        const won = playerWinnings[player.name] || 0;
        const shouldPay = ticketPrice;
        const netAmount = won - shouldPay;
        
        settlements.push({
            name: player.name,
            phone: player.phone,
            shouldPay: shouldPay,
            won: won,
            net: netAmount
        });
    });
    
    // Sort by net amount (who receives most to who owes most)
    settlements.sort((a, b) => b.net - a.net);
    
    // Create display
    let html = `
        <div style="background: #f9fafb; padding: 1rem; border-radius: 0.75rem; margin-bottom: 1rem;">
            <h3 style="font-size: 1rem; margin-bottom: 0.75rem;">Settlement Summary</h3>
            <table style="width: 100%; font-size: 0.875rem;">
                <thead>
                    <tr style="border-bottom: 2px solid #e5e7eb;">
                        <th style="text-align: left; padding: 0.5rem;">Player</th>
                        <th style="text-align: right; padding: 0.5rem;">Ticket</th>
                        <th style="text-align: right; padding: 0.5rem;">Won</th>
                        <th style="text-align: right; padding: 0.5rem;">Net</th>
                    </tr>
                </thead>
                <tbody>
    `;
    
    let totalToCollect = 0;
    let totalToPay = 0;
    
    settlements.forEach(s => {
        let statusColor = '#6b7280';
        let statusText = 'Settled';
        
        if (s.net > 0) {
            statusColor = '#10b981';
            statusText = `Receives ₹${s.net}`;
            totalToPay += s.net;
        } else if (s.net < 0) {
            statusColor = '#ef4444';
            statusText = `Owes ₹${Math.abs(s.net)}`;
            totalToCollect += Math.abs(s.net);
        }
        
        html += `
            <tr style="border-bottom: 1px solid #f3f4f6;">
                <td style="padding: 0.5rem;">${s.name}</td>
                <td style="text-align: right; padding: 0.5rem;">₹${s.shouldPay}</td>
                <td style="text-align: right; padding: 0.5rem;">₹${s.won}</td>
                <td style="text-align: right; padding: 0.5rem; color: ${statusColor}; font-weight: 600;">${statusText}</td>
            </tr>
        `;
    });
    
    html += `
                </tbody>
            </table>
        </div>
        
        <div style="background: #fee2e2; padding: 1rem; border-radius: 0.75rem; margin-bottom: 1rem;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                <span>Total to Collect:</span>
                <span style="font-weight: 600;">₹${totalToCollect}</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
                <span>Total to Pay Out:</span>
                <span style="font-weight: 600;">₹${totalToPay}</span>
            </div>
        </div>
    `;
    
    // Simplified settlement instructions
    const receivers = settlements.filter(s => s.net > 0);
    const payers = settlements.filter(s => s.net < 0);
    
    if (receivers.length > 0 && payers.length > 0) {
        html += `
            <div style="background: #ecfdf5; padding: 1rem; border-radius: 0.75rem; margin-bottom: 1rem;">
                <h4 style="font-size: 0.875rem; font-weight: 600; margin-bottom: 0.5rem;">Simplified Payments:</h4>
                <div style="font-size: 0.8125rem; line-height: 1.5;">
        `;
        
        // Simple algorithm: Pay highest receivers first
        let payerIndex = 0;
        let remainingToPay = Math.abs(payers[payerIndex].net);
        
        receivers.forEach(receiver => {
            let amountToReceive = receiver.net;
            
            while (amountToReceive > 0 && payerIndex < payers.length) {
                const payment = Math.min(amountToReceive, remainingToPay);
                
                html += `• ${payers[payerIndex].name} pays ₹${payment} to ${receiver.name}<br>`;
                
                amountToReceive -= payment;
                remainingToPay -= payment;
                
                if (remainingToPay === 0) {
                    payerIndex++;
                    if (payerIndex < payers.length) {
                        remainingToPay = Math.abs(payers[payerIndex].net);
                    }
                }
            }
        });
        
        html += `
                </div>
            </div>
        `;
    }
    
    html += `
        <button class="btn btn-success" onclick="shareSettlement(${ticketPrice})">Share on WhatsApp</button>
    `;
    
    resultDiv.innerHTML = html;
}

// Share settlement on WhatsApp
function shareSettlement(ticketPrice) {
    let message = `💰 *HOUSIE SETTLEMENT SUMMARY* 💰\n\n`;
    message += `Ticket Price: ₹${ticketPrice} per person\n`;
    message += `━━━━━━━━━━━━━━━━\n\n`;
    
    const playerWinnings = {};
    
    // Calculate winnings
    gameState.gameTypes.forEach(type => {
        const winnersData = gameState.winners[type] || { list: [], winningNumbers: {} };
        const prize = gameState.prizes[type] || 0;
        
        if (winnersData.winningNumbers && !Array.isArray(winnersData)) {
            for (const [num, winnersOnNum] of Object.entries(winnersData.winningNumbers)) {
                if (winnersOnNum && winnersOnNum.length > 0) {
                    const splitPrize = Math.round(prize / winnersOnNum.length);
                    winnersOnNum.forEach(winner => {
                        if (!playerWinnings[winner]) playerWinnings[winner] = 0;
                        playerWinnings[winner] += splitPrize;
                    });
                }
            }
        } else {
            const winnersList = Array.isArray(winnersData) ? winnersData : (winnersData.list || []);
            if (winnersList.length > 0) {
                const splitPrize = Math.round(prize / winnersList.length);
                winnersList.forEach(winner => {
                    if (!playerWinnings[winner]) playerWinnings[winner] = 0;
                    playerWinnings[winner] += splitPrize;
                });
            }
        }
    });
    
    // Create settlements
    const settlements = [];
    gameState.players.forEach(player => {
        const won = playerWinnings[player.name] || 0;
        const net = won - ticketPrice;
        settlements.push({ name: player.name, won, net });
    });
    
    settlements.sort((a, b) => b.net - a.net);
    
    // Add player details
    message += `📊 *Player Settlement:*\n`;
    settlements.forEach(s => {
        if (s.net > 0) {
            message += `✅ ${s.name}: Receives ₹${s.net}\n`;
        } else if (s.net < 0) {
            message += `❌ ${s.name}: Owes ₹${Math.abs(s.net)}\n`;
        } else {
            message += `✓ ${s.name}: Settled (₹0)\n`;
        }
    });
    
    message += `\n━━━━━━━━━━━━━━━━\n`;
    message += `💳 *Payment Instructions:*\n`;
    
    // Calculate simplified payments
    const receivers = settlements.filter(s => s.net > 0);
    const payers = settlements.filter(s => s.net < 0);
    
    let payerIndex = 0;
    let remainingToPay = Math.abs(payers[payerIndex]?.net || 0);
    
    receivers.forEach(receiver => {
        let amountToReceive = receiver.net;
        
        while (amountToReceive > 0 && payerIndex < payers.length) {
            const payment = Math.min(amountToReceive, remainingToPay);
            
            message += `• ${payers[payerIndex].name} → ${receiver.name}: ₹${payment}\n`;
            
            amountToReceive -= payment;
            remainingToPay -= payment;
            
            if (remainingToPay === 0) {
                payerIndex++;
                if (payerIndex < payers.length) {
                    remainingToPay = Math.abs(payers[payerIndex].net);
                }
            }
        }
    });
    
    message += `\n✨ All settlements done! ✨`;
    
    // Create share URL
    const whatsappUrl = `https://wa.me/?text=${encodeURIComponent(message)}`;
    window.open(whatsappUrl, '_blank');
}
       // Display winners summary (for URL access)
       function displayWinnersSummary(summaryData) {
           hideAll();
           
           // Create a special view for the summary
           const container = document.querySelector('.container');
           container.innerHTML = `
               <div class="header">
                   <h1>🎉 Housie Game Results</h1>
               </div>
               <div class="card">
                   <h2>Prize Pool: ₹${summaryData.kittyAmount}</h2>
                   <div id="summaryWinnersList"></div>
                   <div id="summaryPlayerWise" class="winner-summary">
                       <h3>Player-wise Summary</h3>
                       <div id="summaryPlayerList"></div>
                   </div>
                   <button class="btn btn-primary" onclick="window.location.href='https://chopra3sahil.github.io/tembola/'">Start New Game</button>
               </div>
           `;
           
           const winnersListDiv = document.getElementById('summaryWinnersList');
           const playerList = document.getElementById('summaryPlayerList');
           const playerWinnings = {};
           
           // Display game-wise winners
           summaryData.gameTypes.forEach(type => {
               const prize = summaryData.prizes[type] || 0;
               const winnersData = summaryData.winners[type] || { list: [], winningNumbers: {} };
               const winnersList = Array.isArray(winnersData) ? winnersData : (winnersData.list || []);
               
               const div = document.createElement('div');
               div.className = 'winner-item';
               
               if (winnersList.length === 0) {
                   div.innerHTML = `<span>${getGameTypeName(type)} (₹${prize})</span><span class="winner-badge">No Winner</span>`;
               } else {
                   // Group winners by the number they won on
                   const winnerGroups = {};
                   let hasWinningNumbers = false;
                   
                   if (winnersData.winningNumbers && !Array.isArray(winnersData)) {
                       hasWinningNumbers = true;
                       // Group all winners by their winning number
                       for (const [num, winnersOnNum] of Object.entries(winnersData.winningNumbers)) {
                           if (winnersOnNum && winnersOnNum.length > 0) {
                               winnersOnNum.forEach(winner => {
                                   if (!winnerGroups[num]) winnerGroups[num] = [];
                                   if (!winnerGroups[num].includes(winner)) {
                                       winnerGroups[num].push(winner);
                                   }
                               });
                           }
                       }
                   }
                   
                   // Calculate prizes
                   if (hasWinningNumbers && Object.keys(winnerGroups).length > 0) {
                       let maxGroupSize = 1;
                       let hasMultipleWinnersOnSameNumber = false;
                       
                       // First pass - find the maximum group size
                       for (const [num, winnersOnNum] of Object.entries(winnerGroups)) {
                           if (winnersOnNum.length > maxGroupSize) {
                               maxGroupSize = winnersOnNum.length;
                               hasMultipleWinnersOnSameNumber = true;
                           }
                       }
                       
                       // Second pass - calculate winnings
                       for (const [num, winnersOnNum] of Object.entries(winnerGroups)) {
                           if (winnersOnNum.length === maxGroupSize && maxGroupSize > 1) {
                               // These winners share the prize
                               const splitPrize = Math.round(prize / maxGroupSize);
                               winnersOnNum.forEach(winner => {
                                   if (!playerWinnings[winner]) playerWinnings[winner] = 0;
                                   playerWinnings[winner] += splitPrize;
                               });
                           } else {
                               // Single winner on this number - gets full prize
                               winnersOnNum.forEach(winner => {
                                   if (!playerWinnings[winner]) playerWinnings[winner] = 0;
                                   playerWinnings[winner] += prize;
                               });
                           }
                       }
                       
                       if (hasMultipleWinnersOnSameNumber) {
                           const splitPrize = Math.round(prize / maxGroupSize);
                           div.innerHTML = `<span>${getGameTypeName(type)} (₹${splitPrize} each - same number)</span><span class="winner-badge">${winnersList.join(', ')}</span>`;
                       } else {
                           div.innerHTML = `<span>${getGameTypeName(type)} (₹${prize})</span><span class="winner-badge">${winnersList.join(', ')}</span>`;
                       }
                   } else {
                       div.innerHTML = `<span>${getGameTypeName(type)} (₹${prize})</span><span class="winner-badge">${winnersList.join(', ')}</span>`;
                       winnersList.forEach(winner => {
                           if (!playerWinnings[winner]) playerWinnings[winner] = 0;
                           playerWinnings[winner] += prize;
                       });
                   }
               }
               
               winnersListDiv.appendChild(div);
           });
           
           // Display player-wise summary
           const sortedWinners = Object.keys(playerWinnings).sort((a, b) => playerWinnings[b] - playerWinnings[a]);
           sortedWinners.forEach(name => {
               const item = document.createElement('div');
               item.className = 'winner-summary-item';
               item.innerHTML = `<span>${name}</span><span>₹${playerWinnings[name]}</span>`;
               playerList.appendChild(item);
           });
           
           // Add total
           const totalDistributed = Object.values(playerWinnings).reduce((sum, amount) => sum + amount, 0);
           const totalItem = document.createElement('div');
           totalItem.className = 'winner-summary-item';
           totalItem.innerHTML = `<span>Total Distributed</span><span>₹${totalDistributed}</span>`;
           playerList.appendChild(totalItem);
       }

       // Show players
       function showPlayers() {
           const playersList = document.getElementById('playersList');
           playersList.innerHTML = '';
           
           gameState.players.forEach(player => {
               // Create ticket URL for this player
               const ticketData = {
                   name: player.name,
                   phone: player.phone,
                   ticket: player.ticket,
                   games: gameState.gameTypes,
                   prizes: gameState.prizes,
                   sequenceMode: gameState.sequenceMode,
                   rageClickEnabled: gameState.rageClickEnabled,
                   rageClickThreshold: gameState.rageClickThreshold,
                   passKey1: gameState.passKey1,
                   passKey2: gameState.passKey2
               };
               
               if (gameState.sequenceMode === 'predetermined') {
                   ticketData.predeterminedSequence = gameState.predeterminedSequence;
                   ticketData.predeterminedWinners = gameState.predeterminedWinners;
               }
               
               const encodedData = encodeTicketData(ticketData);
               const ticketUrl = `https://chopra3sahil.github.io/tembola/?data=${encodedData}`;
               
               const playerDiv = document.createElement('div');
               playerDiv.className = 'player-item';
               playerDiv.innerHTML = `
                   <div>
                       <strong>${player.name}</strong><br>
                       <small style="color: var(--text-secondary);">${player.phone}</small>
                   </div>
                   <button class="copy-btn" onclick="copyLink('${ticketUrl}')">Copy URL</button>
               `;
               playersList.appendChild(playerDiv);
           });
           
           // Add the "Add Player" button before showing the modal
const modalContent = document.querySelector('#playersModal .modal-content');
if (!modalContent.querySelector('.add-player-btn')) {
    const addPlayerBtn = document.createElement('button');
    addPlayerBtn.className = 'btn btn-success add-player-btn';
    addPlayerBtn.textContent = 'Add New Player';
    addPlayerBtn.onclick = addNewPlayer;
    addPlayerBtn.style.marginBottom = '1rem';
    
    // Insert before the close button
    const closeBtn = modalContent.querySelector('.btn-secondary');
    modalContent.insertBefore(addPlayerBtn, closeBtn);
}

document.getElementById('playersModal').style.display = 'flex';
       }
// Add new player from players modal
function addNewPlayer() {
    const name = prompt('Enter player name:');
    if (!name || !name.trim()) return;
    
    const phone = prompt('Enter player phone number:');
    if (!phone || !phone.trim()) return;
    
    const trimmedName = name.trim();
    const trimmedPhone = phone.trim();
    
    // Validate phone contains only numbers
    if (!/^\d+$/.test(trimmedPhone)) {
        alert('Phone number must contain only digits!');
        return;
    }
    
    // Check for duplicate name
    const duplicateName = gameState.players.find(p => 
        p.name.toLowerCase() === trimmedName.toLowerCase()
    );
    if (duplicateName) {
        alert(`A player with the name "${trimmedName}" already exists!`);
        return;
    }
    
    // Check for duplicate phone
    const duplicatePhone = gameState.players.find(p => 
        p.phone === trimmedPhone
    );
    if (duplicatePhone) {
        alert(`This phone number "${trimmedPhone}" is already registered to ${duplicatePhone.name}!`);
        return;
    }
    
    // Generate ticket for new player
    const ticket = generateTicket();
    
    // Add to game state
    gameState.players.push({ name: trimmedName, phone: trimmedPhone, ticket });
    gameState.tickets[trimmedPhone] = { name: trimmedName, ticket, marked: [] };
    
    // Save updated state
    saveGameState();
    
    // Refresh the players list
    showPlayers();
    
    // Send ticket to the new player
    const ticketData = {
        name: trimmedName,
        phone: trimmedPhone,
        ticket: ticket,
        games: gameState.gameTypes,
        prizes: gameState.prizes,
        sequenceMode: gameState.sequenceMode,
        rageClickEnabled: gameState.rageClickEnabled,
        rageClickThreshold: gameState.rageClickThreshold,
        passKey1: gameState.passKey1,
        passKey2: gameState.passKey2,
        expiryTime: 0  // Will be set below
    };
    
    // Use same expiry settings as original tickets
    const savedGame = localStorage.getItem('housieGame');
    if (savedGame) {
        const state = JSON.parse(savedGame);
        const expiryValue = state.ticketExpiryValue || state.ticketExpiryHours || 0;
        const expiryUnit = state.ticketExpiryUnit || 'hours';
        
        if (expiryValue > 0) {
            if (expiryUnit === 'minutes') {
                ticketData.expiryTime = Date.now() + (expiryValue * 60 * 1000);
            } else {
                ticketData.expiryTime = Date.now() + (expiryValue * 60 * 60 * 1000);
            }
        }
    }
    
    if (gameState.sequenceMode === 'predetermined') {
        ticketData.predeterminedSequence = gameState.predeterminedSequence;
        ticketData.predeterminedWinners = gameState.predeterminedWinners;
    }
    
    const encodedData = encodeTicketData(ticketData);
    const ticketUrl = `https://chopra3sahil.github.io/tembola/?data=${encodedData}`;
    
    // Ask if they want to share immediately
    if (confirm(`Player added successfully! Do you want to share the ticket URL with ${trimmedName} on WhatsApp?`)) {
        shareOnWhatsApp(trimmedName, trimmedPhone, encodedData);
    }
}
       // Close modal
       function closeModal(modalId) {
           document.getElementById(modalId).style.display = 'none';
       }

       // End game
       function endGame() {
           if (confirm('Are you sure you want to end this game?')) {
               localStorage.removeItem('housieGame');
               
               if (gameState.autoPlayInterval) {
                   clearInterval(gameState.autoPlayInterval);
               }
               
               gameState = {
                   gameTypes: [],
                   players: [],
                   calledNumbers: [],
                   winners: {},
                   isAutoPlay: false,
                   autoPlayInterval: null,
                   tickets: {},
                   sequenceMode: 'random',
                   predeterminedSequence: [],
                   predeterminedWinners: {},
                   rageClickEnabled: true,
                   rageClickThreshold: 3
               };
               
               showLanding();
           }
       }

       // Save game state
      function saveGameState() {
    const stateToSave = {
        ...gameState,
        winnerDistribution: gameState.winnerDistribution || 'random'
    };
    localStorage.setItem('housieGame', JSON.stringify(stateToSave));
}

       // Highlight winning pattern with auto-remove
       function highlightWinningPattern(type) {
           const ticket = window.currentTicket;
           if (!ticket) return;
           
           const cells = document.querySelectorAll('.ticket-cell');
           const allNumbers = ticket.flat().filter(n => n > 0);
           
           // Remove any existing highlights
           cells.forEach(cell => cell.classList.remove('pattern-winner'));
           
           // Clear any existing timeout for this pattern
           if (patternTimeouts[type]) {
               clearTimeout(patternTimeouts[type]);
           }
           
           // Get glow duration from saved state or default
           const savedGame = localStorage.getItem('housieGame');
           let glowDuration = 5;
           if (savedGame) {
               const state = JSON.parse(savedGame);
               glowDuration = state.glowDuration || 5;
           }
           
           setTimeout(() => {
               let highlightedCells = [];
               
               switch (type) {
                   case 'firstFive':
                   case 'lucky7':
                       // Highlight the first 5 or 7 marked numbers
                       const marked = window.sessionMarked || [];
                       const limit = type === 'firstFive' ? 5 : 7;
                       let count = 0;
                       cells.forEach((cell, index) => {
                           if (cell.textContent && marked.includes(parseInt(cell.textContent)) && count < limit) {
                               cell.classList.add('pattern-winner');
                               highlightedCells.push(cell);
                               count++;
                           }
                       });
                       break;
                       
                   case 'topLine':
                       // Highlight first row
                       for (let i = 0; i < 9; i++) {
                           if (ticket[0][i] > 0) {
                               cells[i].classList.add('pattern-winner');
                               highlightedCells.push(cells[i]);
                           }
                       }
                       break;
                       
                   case 'middleLine':
                       // Highlight middle row
                       for (let i = 0; i < 9; i++) {
                           if (ticket[1][i] > 0) {
                               cells[i + 9].classList.add('pattern-winner');
                               highlightedCells.push(cells[i + 9]);
                           }
                       }
                       break;
                       
                   case 'bottomLine':
                       // Highlight bottom row
                       for (let i = 0; i < 9; i++) {
                           if (ticket[2][i] > 0) {
                               cells[i + 18].classList.add('pattern-winner');
                               highlightedCells.push(cells[i + 18]);
                           }
                       }
                       break;
                       
                   case 'corners':
                       // Highlight corners
                       const corners = [];
                       // Top left
                       for (let i = 0; i < 9; i++) {
                           if (ticket[0][i] > 0) {
                               cells[i].classList.add('pattern-winner');
                               highlightedCells.push(cells[i]);
                               break;
                           }
                       }
                       // Top right
                       for (let i = 8; i >= 0; i--) {
                           if (ticket[0][i] > 0 && !cells[i].classList.contains('pattern-winner')) {
                               cells[i].classList.add('pattern-winner');
                               highlightedCells.push(cells[i]);
                               break;
                           }
                       }
                       // Bottom left
                       for (let i = 0; i < 9; i++) {
                           if (ticket[2][i] > 0 && !cells[i + 18].classList.contains('pattern-winner')) {
                               cells[i + 18].classList.add('pattern-winner');
                               highlightedCells.push(cells[i + 18]);
                               break;
                           }
                       }
                       // Bottom right
                       for (let i = 8; i >= 0; i--) {
                           if (ticket[2][i] > 0 && !cells[i + 18].classList.contains('pattern-winner')) {
                               cells[i + 18].classList.add('pattern-winner');
                               highlightedCells.push(cells[i + 18]);
                               break;
                           }
                       }
                       break;
                       
                   case 'pyramid':
                       // Highlight pyramid pattern based on number positions
                       const topRowNumsPyr = ticket[0].filter(n => n > 0);
                       const middleRowNumsPyr = ticket[1].filter(n => n > 0);
                       const bottomRowNumsPyr = ticket[2].filter(n => n > 0);
                       
                       if (topRowNumsPyr.length === 5 && middleRowNumsPyr.length === 5 && bottomRowNumsPyr.length === 5) {
                           // Find and highlight the middle number in top row
                           const topMiddle = topRowNumsPyr[2];
                           for (let i = 0; i < 9; i++) {
                               if (ticket[0][i] === topMiddle) {
                                   cells[i].classList.add('pattern-winner');
                                   highlightedCells.push(cells[i]);
                                   break;
                               }
                           }
                           
                           // Find and highlight middle 3 numbers in middle row
                           const middleThree = [middleRowNumsPyr[1], middleRowNumsPyr[2], middleRowNumsPyr[3]];
                           middleThree.forEach(num => {
                               for (let i = 0; i < 9; i++) {
                                   if (ticket[1][i] === num) {
                                       cells[i + 9].classList.add('pattern-winner');
                                       highlightedCells.push(cells[i + 9]);
                                       break;
                                   }
                               }
                           });
                           
                           // Highlight all 5 numbers in bottom row
                           bottomRowNumsPyr.forEach(num => {
                               for (let i = 0; i < 9; i++) {
                                   if (ticket[2][i] === num) {
                                       cells[i + 18].classList.add('pattern-winner');
                                       highlightedCells.push(cells[i + 18]);
                                       break;
                                   }
                               }
                           });
                       }
                       break;
                       
                   case 'railwayTrack':
                       // Highlight top and bottom rows
                       for (let i = 0; i < 9; i++) {
                           if (ticket[0][i] > 0) {
                               cells[i].classList.add('pattern-winner');
                               highlightedCells.push(cells[i]);
                           }
                           if (ticket[2][i] > 0) {
                               cells[i + 18].classList.add('pattern-winner');
                               highlightedCells.push(cells[i + 18]);
                           }
                       }
                       break;
                       
                   case 'firstTwoLines':
                       // Highlight first two rows
                       for (let i = 0; i < 9; i++) {
                           if (ticket[0][i] > 0) {
                               cells[i].classList.add('pattern-winner');
                               highlightedCells.push(cells[i]);
                           }
                           if (ticket[1][i] > 0) {
                               cells[i + 9].classList.add('pattern-winner');
                               highlightedCells.push(cells[i + 9]);
                           }
                       }
                       break;
                       
                   case 'lastTwoLines':
                       // Highlight last two rows
                       for (let i = 0; i < 9; i++) {
                           if (ticket[1][i] > 0) {
                               cells[i + 9].classList.add('pattern-winner');
                               highlightedCells.push(cells[i + 9]);
                           }
                           if (ticket[2][i] > 0) {
                               cells[i + 18].classList.add('pattern-winner');
                               highlightedCells.push(cells[i + 18]);
                           }
                       }
                       break;
                       
                   case 'centerColumn':
                       // Highlight center column
                       if (ticket[0][4] > 0) {
                           cells[4].classList.add('pattern-winner');
                           highlightedCells.push(cells[4]);
                       }
                       if (ticket[1][4] > 0) {
                           cells[13].classList.add('pattern-winner');
                           highlightedCells.push(cells[13]);
                       }
                       if (ticket[2][4] > 0) {
                           cells[22].classList.add('pattern-winner');
                           highlightedCells.push(cells[22]);
                       }
                       break;
                       
                   case 'bullsEye':
                       // Highlight middle number from middle row
                       const middleRowNumsBE = ticket[1].filter(n => n > 0);
                       if (middleRowNumsBE.length === 5) {
                           const middleNumber = middleRowNumsBE[2];
                           // Find this number in the middle row and highlight it
                           for (let i = 0; i < 9; i++) {
                               if (ticket[1][i] === middleNumber) {
                                   cells[i + 9].classList.add('pattern-winner');
                                   highlightedCells.push(cells[i + 9]);
                                   break;
                               }
                           }
                       }
                       break;
                       
                   case 'breakfast':
                       // Highlight first 3 columns
                       for (let col = 0; col < 3; col++) {
                           for (let row = 0; row < 3; row++) {
                               if (ticket[row][col] > 0) {
                                   const index = row * 9 + col;
                                   cells[index].classList.add('pattern-winner');
                                   highlightedCells.push(cells[index]);
                               }
                           }
                       }
                       break;
                       
                   case 'lunch':
                       // Highlight middle 3 columns (3,4,5)
                       for (let col = 3; col < 6; col++) {
                           for (let row = 0; row < 3; row++) {
                               if (ticket[row][col] > 0) {
                                   const index = row * 9 + col;
                                   cells[index].classList.add('pattern-winner');
                                   highlightedCells.push(cells[index]);
                               }
                           }
                       }
                       break;
                       
                   case 'dinner':
                       // Highlight last 3 columns
                       for (let col = 6; col < 9; col++) {
                           for (let row = 0; row < 3; row++) {
                               if (ticket[row][col] > 0) {
                                   const index = row * 9 + col;
                                   cells[index].classList.add('pattern-winner');
                                   highlightedCells.push(cells[index]);
                               }
                           }
                       }
                       break;
                       
                   case 'fullHouse':
                   case 'house1':
                   case 'house2':
                       // Highlight all cells
                       cells.forEach(cell => {
                           if (cell.textContent) {
                               cell.classList.add('pattern-winner');
                               highlightedCells.push(cell);
                           }
                       });
                       break;
               }
               
               // Check for vibrant theme
               const ticketContainer = document.getElementById('ticketContainer');
               const isVibrantTheme = ticketContainer && ticketContainer.classList.contains('theme-vibrant');
               
               // Add pattern-winner class to highlighted cells
               highlightedCells.forEach((cell, index) => {
                   cell.classList.add('pattern-winner');
                   
                   // For vibrant theme, add color classes
                   if (isVibrantTheme) {
                       const colorIndex = (index % 8) + 1;
                       cell.classList.add(`color-${colorIndex}`);
                   }
               });
               
               // Set timeout to remove highlights
               patternTimeouts[type] = setTimeout(() => {
                   highlightedCells.forEach(cell => {
                       cell.classList.remove('pattern-winner');
                       
                       // For vibrant theme, restore original colors for marked cells
                       if (isVibrantTheme && cell.classList.contains('marked')) {
                           // Remove pattern color classes
                           for (let i = 1; i <= 8; i++) {
                               cell.classList.remove(`color-${i}`);
                           }
                           // Add back a random color
                           const randomColor = Math.floor(Math.random() * 8) + 1;
                           cell.classList.add(`color-${randomColor}`);
                       }
                   });
                   delete patternTimeouts[type];
               }, glowDuration * 1000);
           }, 100);
       }
       
       // Initialize on load
       window.onload = init;
   </script>
</body>
</html>